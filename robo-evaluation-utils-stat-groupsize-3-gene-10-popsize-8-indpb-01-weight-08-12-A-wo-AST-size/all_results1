[sll/singleton] singly-linked list: construct a list with one element

[35m
[sll/singleton]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid sll_singleton(x int, ret loc) []
{ret :-> a}
{elems == {x} ; ret :-> y ** sll(y, elems)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 663 milliseconds:[0m
[0mGoals generated: 45[0m
[0mGoals expanded: 37[0m
[0mAnd-nodes backtracked: 14[0m
[0mMaximum worklist size: 9[0m
[0mMaximum goal depth: 22[0m
[0mFinal memo size: (12,23,0)[0m
[0mFinal size of SMT cache: 40[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 1 times (9ms), failed 30 times (164ms)
CheckPost: succeeded 8 times (71ms), failed 8 times (10ms)
Inconsistency: succeeded 0 times (0ms), failed 32 times (35ms)
Read: succeeded 1 times (14ms), failed 31 times (11ms)
*Partial: succeeded 3 times (5ms), failed 20 times (15ms)
[0m
[0mSMTSolving  430ms
            430ms[0m
[0mvoid sll_singleton (int x, loc ret) {
  let y = malloc(2);
  *ret = y;
  *(y + 1) = 0;
  *y = x;
}[0m
[0m-----------------------------------------------------[0m
[sll/init] should be able to initialize a linked list

[35m
[sll/init]:[0m
[0m[0m
[34mvoid sll_init(x loc, v int) []
{sll(x, s)<_alpha_3>}
{s1 <= {v} ; sll(x, s1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1107 milliseconds:[0m
[0mGoals generated: 128[0m
[0mGoals expanded: 119[0m
[0mAnd-nodes backtracked: 84[0m
[0mMaximum worklist size: 10[0m
[0mMaximum goal depth: 29[0m
[0mFinal memo size: (69,35,0)[0m
[0mFinal size of SMT cache: 96[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 2 times (12ms), failed 88 times (370ms)
CheckPost: succeeded 26 times (107ms), failed 15 times (11ms)
Inconsistency: succeeded 0 times (0ms), failed 88 times (54ms)
*Partial: succeeded 0 times (0ms), failed 57 times (22ms)
Open: succeeded 2 times (21ms), failed 2 times (0ms)
[0m
[0mSMTSolving          682ms
CyclicProofChecker  0ms  
                    682ms[0m
[0mvoid sll_init (loc x, int v) {
  if (x == 0) {
  } else {
    let n = *(x + 1);
    sll_init(n, v);
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/free2] Deallocate two linked lists (needs listfree as an auxiliary, unless we can pass emp as a list)

[35m
[sll/free2]:[0m
[0m[0m
[34mvoid listfree2(x loc, y loc) []
{sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4>}
{emp}
[0m
[32mSuccessfully synthesised in 683 milliseconds:[0m
[0mGoals generated: 66[0m
[0mGoals expanded: 66[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 5[0m
[0mMaximum goal depth: 19[0m
[0mFinal memo size: (0,59,0)[0m
[0mFinal size of SMT cache: 32[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 38 times (195ms)
Open: succeeded 5 times (34ms), failed 2 times (0ms)
CheckPost: succeeded 0 times (0ms), failed 15 times (26ms)
AbduceCall: succeeded 4 times (12ms), failed 3 times (8ms)
Read: succeeded 8 times (13ms), failed 30 times (6ms)
[0m
[0mSMTSolving          362ms
CyclicProofChecker  0ms  
                    362ms[0m
[0mvoid listfree2 (loc x, loc y) {
  if (x == 0) {
    listfree200(y);
  } else {
    let n = *(x + 1);
    listfree2(n, y);
    free(x);
  }
}

void listfree200 (loc y) {
  if (y == 0) {
  } else {
    let n = *(y + 1);
    listfree200(n);
    free(y);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/append-copy] append multiple lists

[0mGoals generated: 2697[0m
[0mGoals expanded: 2660[0m
[0mAnd-nodes backtracked: 1813[0m
[0mMaximum worklist size: 300[0m
[0mMaximum goal depth: 46[0m
[0mFinal memo size: (1201,10,566)[0m
[0mFinal size of SMT cache: 933[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 455 times (1057ms), failed 1152 times (2219ms)
HeapUnifyUnfold: succeeded 554 times (317ms), failed 134 times (4ms)
CheckPost: succeeded 96 times (218ms), failed 101 times (24ms)
SubstR: succeeded 326 times (96ms), failed 996 times (87ms)
Read: succeeded 7 times (14ms), failed 1508 times (168ms)
[0m
[0mSMTSolving          3558ms
CyclicProofChecker  1ms   
                    3559ms[0m
[sll/unique] deduplicate a list

[35m
[sll/unique]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid unique(r loc) []
{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 3852 milliseconds:[0m
[0mGoals generated: 593[0m
[0mGoals expanded: 582[0m
[0mAnd-nodes backtracked: 410[0m
[0mMaximum worklist size: 17[0m
[0mMaximum goal depth: 86[0m
[0mFinal memo size: (302,161,0)[0m
[0mFinal size of SMT cache: 506[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 40 times (132ms), failed 334 times (842ms)
AbduceBranch: succeeded 118 times (845ms), failed 53 times (32ms)
Inconsistency: succeeded 10 times (22ms), failed 366 times (270ms)
CheckPost: succeeded 12 times (88ms), failed 33 times (11ms)
Read: succeeded 10 times (12ms), failed 341 times (62ms)
[0m
[0mSMTSolving          2186ms
CyclicProofChecker  0ms   
                    2186ms[0m
[0m{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
void unique (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    unique(r);
    unique01021101014(v, x, r);
  }
}

{_alpha_0x1 < _alpha_3 && not (r == 0) && not (r == x) && not (x == 0) && true ; (x + 1) :-> nxtx11 ** r :-> y1 ** x :-> vx ** ulist(y1, s1x1)<_alpha_41>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** ulist(y, {vx} ++ s1x1)<_alpha_4>}
void unique01021101014 (int vx, loc x, loc r) {
  let y1 = *r;
  if (y1 == 0) {
    *r = x;
    *(x + 1) = 0;
  } else {
    let v = *y1;
    if (vx <= v && v <= vx) {
      let n = *(y1 + 1);
      *r = n;
      unique01021101014(v, y1, r);
      free(x);
    } else {
      let n = *(y1 + 1);
      *r = n;
      *y1 = vx;
      unique01021101014(vx, y1, r);
      let y = *r;
      *r = x;
      *(x + 1) = y;
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/prepend] sorted list: prepend an element

[35m
[srtl/prepend]:[0m
[0m[0m
[34mvoid srtl_prepend(x loc, k int, r loc) []
{0 <= n && k == lower (s + [k]) ; r :-> a ** srtl(x, s, n)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], n + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 729 milliseconds:[0m
[0mGoals generated: 46[0m
[0mGoals expanded: 41[0m
[0mAnd-nodes backtracked: 14[0m
[0mMaximum worklist size: 6[0m
[0mMaximum goal depth: 26[0m
[0mFinal memo size: (10,27,0)[0m
[0mFinal size of SMT cache: 40[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 2 times (22ms), failed 31 times (156ms)
CheckPost: succeeded 8 times (79ms), failed 9 times (20ms)
Inconsistency: succeeded 0 times (0ms), failed 34 times (56ms)
Read: succeeded 1 times (15ms), failed 33 times (7ms)
Open: succeeded 1 times (18ms), failed 0 times (0ms)
[0m
[0mSMTSolving  487ms
            487ms[0m
[0mvoid srtl_prepend (loc x, int k, loc r) {
  let y = malloc(2);
  *r = y;
  *(y + 1) = x;
  *y = k;
}[0m
[0m-----------------------------------------------------[0m
[srtl/insert] sorted list: insert an element

[35m
[srtl/insert]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid srtl_insert(x loc, r loc) [k int]
{0 <= l ; r :-> k ** srtl(x, s, l)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], l + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2640 milliseconds:[0m
[0mGoals generated: 313[0m
[0mGoals expanded: 297[0m
[0mAnd-nodes backtracked: 116[0m
[0mMaximum worklist size: 14[0m
[0mMaximum goal depth: 58[0m
[0mFinal memo size: (91,160,0)[0m
[0mFinal size of SMT cache: 256[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 31 times (163ms), failed 169 times (662ms)
AbduceBranch: succeeded 27 times (378ms), failed 26 times (24ms)
Inconsistency: succeeded 9 times (32ms), failed 200 times (243ms)
Read: succeeded 8 times (14ms), failed 180 times (40ms)
SubstR: succeeded 58 times (45ms), failed 144 times (6ms)
[0m
[0mSMTSolving          1586ms
CyclicProofChecker  0ms   
                    1586ms[0m
[0mvoid srtl_insert (loc x, loc r) {
  let k = *r;
  if (x == 0) {
    let y = malloc(2);
    *r = y;
    *y = lower ([] ++ [k]);
    *(y + 1) = 0;
  } else {
    let v = *x;
    if (v <= k) {
      let n = *(x + 1);
      srtl_insert(n, r);
      let y = *r;
      *r = x;
      *(x + 1) = y;
    } else {
      let n = *(x + 1);
      *r = v;
      srtl_insert(n, r);
      let y = *r;
      *r = x;
      *(x + 1) = y;
      *x = k;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/sort] sort a list

[35m
[srtl/sort]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sort(x loc) []
{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2325 milliseconds:[0m
[0mGoals generated: 267[0m
[0mGoals expanded: 252[0m
[0mAnd-nodes backtracked: 103[0m
[0mMaximum worklist size: 14[0m
[0mMaximum goal depth: 66[0m
[0mFinal memo size: (87,140,0)[0m
[0mFinal size of SMT cache: 200[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 25 times (130ms), failed 154 times (697ms)
Inconsistency: succeeded 6 times (20ms), failed 168 times (250ms)
AbduceBranch: succeeded 13 times (155ms), failed 20 times (19ms)
CheckPost: succeeded 10 times (89ms), failed 23 times (20ms)
SubstR: succeeded 61 times (55ms), failed 132 times (2ms)
[0m
[0mSMTSolving          1452ms
CyclicProofChecker  0ms   
                    1452ms[0m
[0m{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
void sort (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    sort(n);
    sort001101013(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_0x < _alpha_3 && not (x == 0) && true ; (x + 1) :-> nx ** x :-> vx ** srtl(nx, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{srtl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void sort001101013 (loc nx, int vx, loc x) {
  if (nx == 0) {
    *(x + 1) = 0;
  } else {
    let v = *nx;
    if (vx <= v) {
      let n = *(nx + 1);
      sort001101013(n, v, nx);
    } else {
      let n = *(nx + 1);
      *nx = vx;
      sort001101013(n, vx, nx);
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/reverse] reverse a list

[35m
[srtl/reverse]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid reverse(x loc) []
{0 <= n ; srtl(x, s, n)<_alpha_3>}
{descl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1675 milliseconds:[0m
[0mGoals generated: 177[0m
[0mGoals expanded: 164[0m
[0mAnd-nodes backtracked: 79[0m
[0mMaximum worklist size: 13[0m
[0mMaximum goal depth: 60[0m
[0mFinal memo size: (68,83,0)[0m
[0mFinal size of SMT cache: 131[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 12 times (67ms), failed 110 times (534ms)
CheckPost: succeeded 20 times (115ms), failed 26 times (49ms)
Inconsistency: succeeded 0 times (0ms), failed 114 times (154ms)
SubstR: succeeded 43 times (41ms), failed 90 times (5ms)
Close: succeeded 13 times (35ms), failed 7 times (0ms)
[0m
[0mSMTSolving          1021ms
CyclicProofChecker  0ms   
                    1021ms[0m
[0m{0 <= n ; srtl(x, s, n)<_alpha_3>}
{descl(x, s, n)<_alpha_4>}
void reverse (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    reverse(n);
    reverse115(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_1x < _alpha_3 && not (x == 0) && vx == lower ([vx] ++ s1x) ; (x + 1) :-> nx ** x :-> vx ** descl(nx, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{descl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void reverse115 (loc nx, int vx, loc x) {
  if (nx == 0) {
    *(x + 1) = 0;
  } else {
    let v = *nx;
    let n = *(nx + 1);
    *nx = vx;
    reverse115(n, vx, nx);
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/merge] sorted list: merge

[0mGoals generated: 1925[0m
[0mGoals expanded: 1855[0m
[0mAnd-nodes backtracked: 1273[0m
[0mMaximum worklist size: 20[0m
[0mMaximum goal depth: 93[0m
[0mFinal memo size: (878,398,183)[0m
[0mFinal size of SMT cache: 1156[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 198 times (889ms), failed 1046 times (4189ms)
AbduceBranch: succeeded 373 times (3036ms), failed 237 times (248ms)
Inconsistency: succeeded 10 times (44ms), failed 1288 times (1110ms)
Read: succeeded 29 times (31ms), failed 1218 times (382ms)
SubstR: succeeded 227 times (189ms), failed 874 times (21ms)
[0m
[0mSMTSolving          8965ms
CyclicProofChecker  0ms   
                    8965ms[0m
[dll/singleton] singly-linked list: construct a list with one element

[35m
[dll/singleton]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid dll_singleton(x int, ret loc) []
{ret :-> a}
{elems == {x} ; ret :-> y ** dll(y, 0, elems)<_alpha_2>}
[0m
[32mSuccessfully synthesised in 647 milliseconds:[0m
[0mGoals generated: 49[0m
[0mGoals expanded: 38[0m
[0mAnd-nodes backtracked: 14[0m
[0mMaximum worklist size: 12[0m
[0mMaximum goal depth: 23[0m
[0mFinal memo size: (12,24,0)[0m
[0mFinal size of SMT cache: 40[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 1 times (8ms), failed 31 times (141ms)
CheckPost: succeeded 8 times (71ms), failed 9 times (15ms)
Inconsistency: succeeded 0 times (0ms), failed 33 times (37ms)
Read: succeeded 1 times (13ms), failed 32 times (11ms)
*Partial: succeeded 3 times (4ms), failed 21 times (15ms)
[0m
[0mSMTSolving  406ms
            406ms[0m
[0mvoid dll_singleton (int x, loc ret) {
  let y = malloc(3);
  *ret = y;
  *(y + 1) = 0;
  *(y + 2) = 0;
  *y = x;
}[0m
[0m-----------------------------------------------------[0m
[dll/append] doubly-linked list: append

[0mGoals generated: 5390[0m
[0mGoals expanded: 5298[0m
[0mAnd-nodes backtracked: 4481[0m
[0mMaximum worklist size: 113[0m
[0mMaximum goal depth: 82[0m
[0mFinal memo size: (2707,196,538)[0m
[0mFinal size of SMT cache: 969[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 71 times (165ms), failed 2955 times (2485ms)
CheckPost: succeeded 1558 times (1087ms), failed 654 times (85ms)
Inconsistency: succeeded 6 times (20ms), failed 2868 times (717ms)
Read: succeeded 62 times (46ms), failed 2806 times (347ms)
Pick: succeeded 370 times (294ms), failed 91 times (1ms)
[0m
[0mSMTSolving          4191ms
CyclicProofChecker  0ms   
                    4191ms[0m
[multi-list/flatten] should be able to flatten a multi-list into a sll

[35m
[multi-list/flatten]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid multilist_flatten(r loc) []
{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> y ** sll(y, len, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2282 milliseconds:[0m
[0mGoals generated: 367[0m
[0mGoals expanded: 315[0m
[0mAnd-nodes backtracked: 65[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 69[0m
[0mFinal memo size: (59,207,0)[0m
[0mFinal size of SMT cache: 191[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 14 times (57ms), failed 221 times (465ms)
Inconsistency: succeeded 0 times (0ms), failed 227 times (376ms)
CheckPost: succeeded 35 times (175ms), failed 65 times (59ms)
Read: succeeded 19 times (34ms), failed 208 times (38ms)
*Partial: succeeded 15 times (12ms), failed 150 times (29ms)
[0m
[0mSMTSolving          1207ms
CyclicProofChecker  0ms   
                    1207ms[0m
[0m{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> y ** sll(y, len, s)<_alpha_4>}
void multilist_flatten (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    multilist_flatten10(x, r);
  }
}

{_alpha_1x1 < _alpha_3 && _alpha_2x1 < _alpha_3 && len == len1x1 + size2x1 && not (r == 0) && not (x == 0) && s =i s1x1 ++ s2x1 ; (x + 1) :-> tx1 ** r :-> x ** x :-> hx1 ** multilist(tx1, size2x1, s2x1)<_alpha_2x1>[0,1] ** sll(hx1, len1x1, s1x1)<_alpha_1x1>[0,1] ** [x, 2]}
{not (r == 0) ; r :-> y ** sll(y, len, s)<_alpha_4>}
void multilist_flatten10 (loc x, loc r) {
  let h = *x;
  let t = *(x + 1);
  if (h == 0) {
    *r = t;
    multilist_flatten(r);
    let y = *r;
    if (y == 0) {
      free(x);
    } else {
      free(x);
    }
  } else {
    let v = *h;
    let n = *(h + 1);
    *(h + 1) = t;
    *h = n;
    *r = h;
    multilist_flatten10(h, r);
    let y = *r;
    *r = x;
    *(x + 1) = y;
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/size] should be able to synthesize tree size

[35m
[tree/size]:[0m
[0m[0m
[34mvoid tree_size(x loc, r loc) []
{0 <= n ; r :-> 0 ** treeN(x, n)<_alpha_6>}
{r :-> n ** treeN(x, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 2623 milliseconds:[0m
[0mGoals generated: 692[0m
[0mGoals expanded: 637[0m
[0mAnd-nodes backtracked: 457[0m
[0mMaximum worklist size: 60[0m
[0mMaximum goal depth: 57[0m
[0mFinal memo size: (314,63,0)[0m
[0mFinal size of SMT cache: 185[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 106 times (90ms), failed 284 times (598ms)
CheckPost: succeeded 40 times (199ms), failed 135 times (78ms)
Inconsistency: succeeded 0 times (0ms), failed 352 times (175ms)
SubstR: succeeded 97 times (50ms), failed 265 times (8ms)
Read: succeeded 7 times (11ms), failed 345 times (45ms)
[0m
[0mSMTSolving          1213ms
CyclicProofChecker  1ms   
                    1214ms[0m
[0mvoid tree_size (loc x, loc r) {
  if (x == 0) {
  } else {
    let l = *(x + 1);
    let rx = *(x + 2);
    tree_size(l, r);
    let n1 = *r;
    *r = 0;
    tree_size(rx, r);
    let n = *r;
    *r = 1 + n1 + n;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/free] should be able to deallocate a tree

[35m
[tree/free]:[0m
[0m[0m
[34mvoid tree_free(x loc) []
{tree(x, s)<_alpha_6>}
{emp}
[0m
[32mSuccessfully synthesised in 474 milliseconds:[0m
[0mGoals generated: 26[0m
[0mGoals expanded: 26[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 2[0m
[0mMaximum goal depth: 23[0m
[0mFinal memo size: (0,26,0)[0m
[0mFinal size of SMT cache: 12[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 14 times (104ms)
Open: succeeded 1 times (22ms), failed 2 times (0ms)
Read: succeeded 3 times (16ms), failed 11 times (5ms)
CheckPost: succeeded 0 times (0ms), failed 8 times (14ms)
Write: succeeded 0 times (0ms), failed 4 times (13ms)
[0m
[0mSMTSolving          280ms
CyclicProofChecker  0ms  
                    280ms[0m
[0mvoid tree_free (loc x) {
  if (x == 0) {
  } else {
    let l = *(x + 1);
    let r = *(x + 2);
    tree_free(l);
    tree_free(r);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/free2] Deallocate two trees

[35m
[tree/free2]:[0m
[0m[0m
[34mvoid treefree2(x loc, y loc) []
{tree(x, s1)<_alpha_6> ** tree(y, s2)<_alpha_7>}
{emp}
[0m
[32mSuccessfully synthesised in 1216 milliseconds:[0m
[0mGoals generated: 213[0m
[0mGoals expanded: 209[0m
[0mAnd-nodes backtracked: 58[0m
[0mMaximum worklist size: 9[0m
[0mMaximum goal depth: 43[0m
[0mFinal memo size: (54,99,0)[0m
[0mFinal size of SMT cache: 61[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 77 times (387ms)
Read: succeeded 18 times (29ms), failed 59 times (17ms)
SubstR: succeeded 72 times (39ms), failed 127 times (2ms)
Open: succeeded 7 times (38ms), failed 8 times (0ms)
CheckPost: succeeded 0 times (0ms), failed 59 times (32ms)
[0m
[0mSMTSolving          569ms
CyclicProofChecker  1ms  
                    570ms[0m
[0mvoid treefree2 (loc x, loc y) {
  if (x == 0) {
    if (y == 0) {
    } else {
      let l = *(y + 1);
      let r = *(y + 2);
      treefree2(l, r);
      free(y);
    }
  } else {
    let lx = *(x + 1);
    let rx = *(x + 2);
    treefree2(lx, rx);
    if (y == 0) {
      free(x);
    } else {
      let l = *(y + 1);
      let r = *(y + 2);
      treefree2(l, r);
      free(y);
      free(x);
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-dll] flatten the tree into a doubly-linked list in place

[0mGoals generated: 3428[0m
[0mGoals expanded: 3358[0m
[0mAnd-nodes backtracked: 2432[0m
[0mMaximum worklist size: 69[0m
[0mMaximum goal depth: 78[0m
[0mFinal memo size: (2042,246,666)[0m
[0mFinal size of SMT cache: 1821[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 130 times (337ms), failed 2281 times (4596ms)
CheckPost: succeeded 520 times (1355ms), failed 324 times (136ms)
Inconsistency: succeeded 36 times (87ms), failed 2363 times (1181ms)
SubstR: succeeded 818 times (368ms), failed 1750 times (26ms)
Read: succeeded 135 times (68ms), failed 2228 times (309ms)
[0m
[0mSMTSolving          7483ms
CyclicProofChecker  1ms   
                    7484ms[0m
[tree/flatten-dll-linear] flatten a tree into a doubly-linked list in learn time

[0mGoals generated: 4046[0m
[0mGoals expanded: 3881[0m
[0mAnd-nodes backtracked: 3116[0m
[0mMaximum worklist size: 99[0m
[0mMaximum goal depth: 82[0m
[0mFinal memo size: (2163,421,332)[0m
[0mFinal size of SMT cache: 1464[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 100 times (264ms), failed 2220 times (3213ms)
CheckPost: succeeded 948 times (1490ms), failed 464 times (667ms)
Inconsistency: succeeded 19 times (62ms), failed 2243 times (754ms)
Read: succeeded 76 times (29ms), failed 2167 times (334ms)
SubstR: succeeded 639 times (270ms), failed 1948 times (37ms)
[0m
[0mSMTSolving          6079ms
CyclicProofChecker  0ms   
                    6079ms[0m
[bst/left-rotate] binary search tree: rotate left

[0mGoals generated: 2979[0m
[0mGoals expanded: 2967[0m
[0mAnd-nodes backtracked: 2738[0m
[0mMaximum worklist size: 60[0m
[0mMaximum goal depth: 64[0m
[0mFinal memo size: (1760,2,210)[0m
[0mFinal size of SMT cache: 1139[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 54 times (257ms), failed 1761 times (5710ms)
CheckPost: succeeded 972 times (2381ms), failed 149 times (124ms)
Read: succeeded 10 times (34ms), failed 1802 times (552ms)
SubstR: succeeded 470 times (368ms), failed 1370 times (92ms)
Inconsistency: succeeded 2 times (9ms), failed 1812 times (326ms)
[0m
[0mSMTSolving  8290ms
            8290ms[0m
[bst/right-rotate] binary search tree: rotate right

[0mGoals generated: 2191[0m
[0mGoals expanded: 2175[0m
[0mAnd-nodes backtracked: 1791[0m
[0mMaximum worklist size: 56[0m
[0mMaximum goal depth: 64[0m
[0mFinal memo size: (1264,2,344)[0m
[0mFinal size of SMT cache: 1112[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 56 times (267ms), failed 1464 times (6962ms)
CheckPost: succeeded 481 times (1471ms), failed 69 times (100ms)
SubstR: succeeded 575 times (643ms), failed 928 times (279ms)
Read: succeeded 10 times (40ms), failed 1517 times (749ms)
Inconsistency: succeeded 2 times (7ms), failed 1527 times (338ms)
[0m
[0mSMTSolving  8753ms
            8753ms[0m
[bst/min] binary search tree: find smallest element

[0mGoals generated: 1971[0m
[0mGoals expanded: 1893[0m
[0mAnd-nodes backtracked: 1281[0m
[0mMaximum worklist size: 143[0m
[0mMaximum goal depth: 74[0m
[0mFinal memo size: (1041,8,539)[0m
[0mFinal size of SMT cache: 888[0m
[0mTime spent cycling: 4ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 14 times (79ms), failed 1166 times (5641ms)
CheckPost: succeeded 376 times (1215ms), failed 377 times (116ms)
SubstR: succeeded 475 times (353ms), failed 1216 times (63ms)
Inconsistency: succeeded 0 times (0ms), failed 871 times (312ms)
Read: succeeded 15 times (24ms), failed 856 times (239ms)
[0m
[0mSMTSolving          7168ms
CyclicProofChecker  2ms   
                    7170ms[0m
[bst/max] binary search tree: find smallest element

[0mGoals generated: 1962[0m
[0mGoals expanded: 1884[0m
[0mAnd-nodes backtracked: 1281[0m
[0mMaximum worklist size: 143[0m
[0mMaximum goal depth: 74[0m
[0mFinal memo size: (1041,8,530)[0m
[0mFinal size of SMT cache: 887[0m
[0mTime spent cycling: 6ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 14 times (78ms), failed 1163 times (5567ms)
CheckPost: succeeded 375 times (1257ms), failed 374 times (107ms)
SubstR: succeeded 470 times (329ms), failed 1211 times (56ms)
Inconsistency: succeeded 0 times (0ms), failed 871 times (298ms)
Read: succeeded 15 times (24ms), failed 856 times (233ms)
[0m
[0mSMTSolving          7110ms
CyclicProofChecker  1ms   
                    7111ms[0m
[bst/delete-root] binary search tree: delete root

[0mGoals generated: 2059[0m
[0mGoals expanded: 2022[0m
[0mAnd-nodes backtracked: 1658[0m
[0mMaximum worklist size: 39[0m
[0mMaximum goal depth: 108[0m
[0mFinal memo size: (1170,78,160)[0m
[0mFinal size of SMT cache: 1029[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 61 times (274ms), failed 1224 times (6502ms)
CheckPost: succeeded 537 times (2604ms), failed 212 times (87ms)
Inconsistency: succeeded 0 times (0ms), failed 1203 times (365ms)
SubstR: succeeded 389 times (303ms), failed 1032 times (57ms)
Read: succeeded 14 times (32ms), failed 1189 times (305ms)
[0m
[0mSMTSolving          9440ms
CyclicProofChecker  0ms   
                    9440ms[0m
[rose-tree/free] should be able to deallocate a rose tree

[35m
[rose-tree/free]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid rose_tree_free(x loc) []
{rose_tree(x, s)<_alpha_7>}
{emp}
[0m
[32mSuccessfully synthesised in 691 milliseconds:[0m
[0mGoals generated: 47[0m
[0mGoals expanded: 45[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 5[0m
[0mMaximum goal depth: 39[0m
[0mFinal memo size: (0,45,0)[0m
[0mFinal size of SMT cache: 28[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 22 times (155ms)
CheckPost: succeeded 2 times (12ms), failed 15 times (43ms)
PostInconsistent: succeeded 0 times (0ms), failed 30 times (26ms)
Open: succeeded 2 times (24ms), failed 2 times (0ms)
Read: succeeded 4 times (11ms), failed 18 times (9ms)
[0m
[0mSMTSolving          380ms
CyclicProofChecker  0ms  
                    380ms[0m
[0m{rose_tree(x, s)<_alpha_7>}
{emp}
void rose_tree_free (loc x) {
  if (x == 0) {
  } else {
    rose_tree_free10(x);
  }
}

{_alpha_0x < _alpha_7 && not (x == 0) && s =i {vx} ++ s1x ; (x + 1) :-> bx ** x :-> vx ** buds(bx, s1x)<_alpha_0x>[0,1] ** [x, 2]}
{emp}
void rose_tree_free10 (loc x) {
  let b = *(x + 1);
  if (b == 0) {
    free(x);
  } else {
    let r = *b;
    rose_tree_free(r);
    rose_tree_free10(b);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[rose-tree/flatten] should be able to flatten a rose tree into a list

[0mGoals generated: 4597[0m
[0mGoals expanded: 4584[0m
[0mAnd-nodes backtracked: 4481[0m
[0mMaximum worklist size: 28[0m
[0mMaximum goal depth: 97[0m
[0mFinal memo size: (2682,27,76)[0m
[0mFinal size of SMT cache: 1067[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 241 times (560ms), failed 2131 times (2181ms)
CheckPost: succeeded 1565 times (1897ms), failed 426 times (205ms)
Pick: succeeded 327 times (368ms), failed 8 times (2ms)
HeapUnifyPure: succeeded 872 times (333ms), failed 882 times (30ms)
Read: succeeded 9 times (21ms), failed 2271 times (235ms)
[0m
[0mSMTSolving          4524ms
CyclicProofChecker  2ms   
                    4526ms[0m
[packed/pack] 

[0mGoals generated: 2934[0m
[0mGoals expanded: 2528[0m
[0mAnd-nodes backtracked: 1483[0m
[0mMaximum worklist size: 542[0m
[0mMaximum goal depth: 26[0m
[0mFinal memo size: (1186,1,909)[0m
[0mFinal size of SMT cache: 507[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 186 times (176ms), failed 1901 times (2457ms)
Close: succeeded 638 times (528ms), failed 281 times (1ms)
SubstR: succeeded 526 times (190ms), failed 1375 times (80ms)
*Partial: succeeded 209 times (78ms), failed 994 times (126ms)
Read: succeeded 3 times (17ms), failed 2087 times (177ms)
[0m
[0mSMTSolving  2708ms
            2708ms[0m
