[ints/swap] should be able to synthesize a swap program

[35m
[ints/swap]:[0m
[0m[0m
[34mvoid swap(x loc, y loc) []
{x :-> a ** y :-> b}
{x :-> b ** y :-> a}
[0m
[32mSuccessfully synthesised in 285 milliseconds:[0m
[0mGoals generated: 14[0m
[0mGoals expanded: 12[0m
[0mAnd-nodes backtracked: 2[0m
[0mMaximum worklist size: 3[0m
[0mMaximum goal depth: 9[0m
[0mFinal memo size: (2,10,0)[0m
[0mFinal size of SMT cache: 10[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 11 times (46ms)
*Partial: succeeded 1 times (22ms), failed 10 times (2ms)
CheckPost: succeeded 2 times (17ms), failed 3 times (5ms)
Write: succeeded 2 times (17ms), failed 1 times (1ms)
HeapUnifyPure: succeeded 3 times (11ms), failed 2 times (0ms)
[0m
[0mSMTSolving  243ms
            243ms[0m
[0mvoid swap (loc x, loc y) {
  let a = *x;
  let b = *y;
  *y = a;
  *x = b;
}[0m
[0m-----------------------------------------------------[0m
[sll/len] singly-linked list: length

[35m
[sll/len]:[0m
[0m[0m
[34mvoid sll_len(x loc, ret loc) []
{0 <= n ; ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{ret :-> n ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1511 milliseconds:[0m
[0mGoals generated: 222[0m
[0mGoals expanded: 205[0m
[0mAnd-nodes backtracked: 124[0m
[0mMaximum worklist size: 22[0m
[0mMaximum goal depth: 43[0m
[0mFinal memo size: (92,50,0)[0m
[0mFinal size of SMT cache: 124[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 12 times (53ms), failed 120 times (305ms)
CheckPost: succeeded 40 times (161ms), failed 54 times (89ms)
Inconsistency: succeeded 0 times (0ms), failed 106 times (106ms)
*Partial: succeeded 2 times (2ms), failed 92 times (36ms)
HeapUnifyPure: succeeded 36 times (20ms), failed 32 times (5ms)
[0m
[0mSMTSolving          823ms
CyclicProofChecker  0ms  
                    823ms[0m
[0mvoid sll_len (loc x, loc ret) {
  if (x == 0) {
    *ret = 0;
  } else {
    let n = *(x + 1);
    sll_len(n, ret);
    let l = *ret;
    *ret = l + 1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/min] singly-linked list: min

[35m
[sll/min]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sll_min(x loc, ret loc) []
{ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{s == [] || m == lower s ; ret :-> m ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 6810 milliseconds:[0m
[0mGoals generated: 904[0m
[0mGoals expanded: 825[0m
[0mAnd-nodes backtracked: 362[0m
[0mMaximum worklist size: 41[0m
[0mMaximum goal depth: 94[0m
[0mFinal memo size: (280,311,0)[0m
[0mFinal size of SMT cache: 774[0m
[0mTime spent cycling: 3ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 63 times (321ms), failed 457 times (1764ms)
AbduceBranch: succeeded 68 times (1004ms), failed 46 times (37ms)
CheckPost: succeeded 41 times (270ms), failed 190 times (300ms)
Inconsistency: succeeded 15 times (40ms), failed 420 times (504ms)
SubstR: succeeded 152 times (107ms), failed 452 times (10ms)
[0m
[0mSMTSolving          4107ms
CyclicProofChecker  1ms   
                    4108ms[0m
[0mvoid sll_min (loc x, loc ret) {
  if (x == 0) {
  } else {
    sll_min010210(x, ret);
  }
}

void sll_min010210 (loc x, loc r) {
  let vx = *x;
  let n = *(x + 1);
  sll_min(n, r);
  let m1 = *r;
  if (m1 <= vx && vx <= m1) {
    *x = m1;
  } else {
    if (n == 0) {
      *r = vx;
      *(x + 1) = 0;
    } else {
      let v = *n;
      if (v <= vx && vx <= v) {
        sll_min010210(n, r);
        *x = m1;
      } else {
        if (v <= vx) {
          sll_min010210(n, r);
        } else {
          sll_min010210(n, r);
          let m = *r;
          if (m <= vx) {
            *x = m1;
          } else {
            *r = vx;
          }
        }
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/singleton] singly-linked list: construct a list with one element

[35m
[sll/singleton]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid sll_singleton(x int, ret loc) []
{ret :-> a}
{elems == {x} ; ret :-> y ** sll(y, elems)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 618 milliseconds:[0m
[0mGoals generated: 44[0m
[0mGoals expanded: 36[0m
[0mAnd-nodes backtracked: 14[0m
[0mMaximum worklist size: 9[0m
[0mMaximum goal depth: 21[0m
[0mFinal memo size: (12,22,0)[0m
[0mFinal size of SMT cache: 38[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 1 times (8ms), failed 30 times (149ms)
CheckPost: succeeded 6 times (68ms), failed 6 times (14ms)
Inconsistency: succeeded 0 times (0ms), failed 31 times (23ms)
*Partial: succeeded 3 times (4ms), failed 27 times (16ms)
FrameBlock: succeeded 1 times (1ms), failed 2 times (15ms)
[0m
[0mSMTSolving  401ms
            401ms[0m
[0mvoid sll_singleton (int x, loc ret) {
  let y = malloc(2);
  *ret = y;
  *(y + 1) = 0;
  *y = x;
}[0m
[0m-----------------------------------------------------[0m
[sll/free] should be able to deallocate a linked list

[35m
[sll/free]:[0m
[0m[0m
[34mvoid sll_free(x loc) []
{sll(x, s)<_alpha_3>}
{emp}
[0m
[32mSuccessfully synthesised in 383 milliseconds:[0m
[0mGoals generated: 16[0m
[0mGoals expanded: 17[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 1[0m
[0mMaximum goal depth: 14[0m
[0mFinal memo size: (0,17,0)[0m
[0mFinal size of SMT cache: 13[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 11 times (70ms)
CheckPost: succeeded 0 times (0ms), failed 8 times (37ms)
Open: succeeded 1 times (20ms), failed 1 times (0ms)
*Partial: succeeded 0 times (0ms), failed 11 times (14ms)
Write: succeeded 0 times (0ms), failed 3 times (12ms)
[0m
[0mSMTSolving          272ms
CyclicProofChecker  0ms  
                    272ms[0m
[0mvoid sll_free (loc x) {
  if (x == 0) {
  } else {
    let n = *(x + 1);
    sll_free(n);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/delete-all] singly-linked list: delete all occurrences of x

[35m
[sll/delete-all]:[0m
[0mbranchAbduction = true[0m
[34mvoid sll_delete_all(x loc, ret loc) []
{ret :-> a ** sll(x, s)<_alpha_3>}
{s1 == s - {a} ; ret :-> y ** sll(y, s1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2816 milliseconds:[0m
[0mGoals generated: 424[0m
[0mGoals expanded: 405[0m
[0mAnd-nodes backtracked: 241[0m
[0mMaximum worklist size: 25[0m
[0mMaximum goal depth: 54[0m
[0mFinal memo size: (187,98,0)[0m
[0mFinal size of SMT cache: 337[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 61 times (640ms), failed 21 times (18ms)
PostInconsistent: succeeded 19 times (46ms), failed 242 times (549ms)
Inconsistency: succeeded 8 times (24ms), failed 222 times (220ms)
CheckPost: succeeded 11 times (24ms), failed 77 times (85ms)
Branch: succeeded 13 times (23ms), failed 209 times (14ms)
[0m
[0mSMTSolving          1647ms
CyclicProofChecker  0ms   
                    1647ms[0m
[0mvoid sll_delete_all (loc x, loc ret) {
  let a = *ret;
  if (x == 0) {
    *ret = 0;
  } else {
    let v = *x;
    if (a <= v && v <= a) {
      let n = *(x + 1);
      sll_delete_all(n, ret);
      free(x);
    } else {
      let n = *(x + 1);
      sll_delete_all(n, ret);
      let y1 = *ret;
      let y = malloc(2);
      free(x);
      *ret = y;
      *y = v;
      *(y + 1) = y1;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/free2] Deallocate two linked lists (needs listfree as an auxiliary, unless we can pass emp as a list)

[35m
[sll/free2]:[0m
[0m[0m
[34mvoid listfree2(x loc, y loc) []
{sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4>}
{emp}
[0m
[32mSuccessfully synthesised in 807 milliseconds:[0m
[0mGoals generated: 66[0m
[0mGoals expanded: 66[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 5[0m
[0mMaximum goal depth: 19[0m
[0mFinal memo size: (0,59,0)[0m
[0mFinal size of SMT cache: 48[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 38 times (194ms)
CheckPost: succeeded 0 times (0ms), failed 31 times (119ms)
Open: succeeded 5 times (35ms), failed 2 times (0ms)
*Partial: succeeded 0 times (0ms), failed 38 times (21ms)
AbduceCall: succeeded 4 times (11ms), failed 3 times (7ms)
[0m
[0mSMTSolving          461ms
CyclicProofChecker  0ms  
                    461ms[0m
[0mvoid listfree2 (loc x, loc y) {
  if (x == 0) {
    listfree200(y);
  } else {
    let n = *(x + 1);
    listfree2(n, y);
    free(x);
  }
}

void listfree200 (loc y) {
  if (y == 0) {
  } else {
    let n = *(y + 1);
    listfree200(n);
    free(y);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/multi-append] append multiple lists

[35m
[sll/multi-append]:[0m
[0m[0m
[34mvoid append3(x loc, y loc, z loc, r loc) []
{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
[0m
[32mSuccessfully synthesised in 1999 milliseconds:[0m
[0mGoals generated: 299[0m
[0mGoals expanded: 250[0m
[0mAnd-nodes backtracked: 82[0m
[0mMaximum worklist size: 25[0m
[0mMaximum goal depth: 56[0m
[0mFinal memo size: (72,167,0)[0m
[0mFinal size of SMT cache: 200[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 6 times (20ms), failed 183 times (508ms)
CheckPost: succeeded 30 times (163ms), failed 77 times (171ms)
Inconsistency: succeeded 0 times (0ms), failed 163 times (184ms)
*Partial: succeeded 13 times (11ms), failed 144 times (39ms)
SubstR: succeeded 54 times (34ms), failed 156 times (5ms)
[0m
[0mSMTSolving          1152ms
CyclicProofChecker  1ms   
                    1153ms[0m
[0m{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
void append3 (loc x, loc y, loc z, loc r) {
  if (x == 0) {
    append300(y, z, r);
  } else {
    let n = *(x + 1);
    append3(n, y, z, r);
    let v = *r;
    *r = x;
    *(x + 1) = v;
  }
}

{not (r == 0) && s1 =i {} && x == 0 ; r :-> a1 ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{not (r == 0) ; r :-> v ** sll(v, s1 ++ s2 ++ s3)<_alpha_6>}
void append300 (loc y, loc z, loc r) {
  if (y == 0) {
    *r = z;
  } else {
    let vy = *y;
    let n = *(y + 1);
    append300(n, z, r);
    let v1 = *r;
    let v = malloc(2);
    free(y);
    *r = v;
    *v = vy;
    *(v + 1) = v1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/union] union of two unique lists

[0mGoals generated: 2770[0m
[0mGoals expanded: 2677[0m
[0mAnd-nodes backtracked: 1952[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 93[0m
[0mFinal memo size: (1416,447,186)[0m
[0mFinal size of SMT cache: 2122[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 180 times (441ms), failed 1463 times (3023ms)
AbduceBranch: succeeded 461 times (3348ms), failed 149 times (78ms)
CheckPost: succeeded 146 times (765ms), failed 278 times (432ms)
Inconsistency: succeeded 18 times (52ms), failed 1516 times (604ms)
Read: succeeded 40 times (27ms), failed 950 times (165ms)
[0m
[0mSMTSolving          8089ms
CyclicProofChecker  0ms   
                    8089ms[0m
[sll/unique] deduplicate a list

[35m
[sll/unique]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid unique(r loc) []
{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 3351 milliseconds:[0m
[0mGoals generated: 484[0m
[0mGoals expanded: 474[0m
[0mAnd-nodes backtracked: 297[0m
[0mMaximum worklist size: 16[0m
[0mMaximum goal depth: 85[0m
[0mFinal memo size: (222,166,0)[0m
[0mFinal size of SMT cache: 411[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 30 times (115ms), failed 280 times (717ms)
AbduceBranch: succeeded 77 times (569ms), failed 30 times (30ms)
Inconsistency: succeeded 12 times (30ms), failed 293 times (276ms)
CheckPost: succeeded 12 times (92ms), failed 52 times (77ms)
*Partial: succeeded 16 times (15ms), failed 231 times (56ms)
[0m
[0mSMTSolving          1894ms
CyclicProofChecker  0ms   
                    1894ms[0m
[0m{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
void unique (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    unique(r);
    unique01021201013(v, x, r);
  }
}

{_alpha_0x1 < _alpha_3 && not (r == 0) && not (r == x) && not (x == 0) && true ; (x + 1) :-> nxtx11 ** r :-> y1 ** x :-> vx ** ulist(y1, s1x1)<_alpha_41>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** ulist(y, {vx} ++ s1x1)<_alpha_4>}
void unique01021201013 (int vx, loc x, loc r) {
  let y1 = *r;
  if (y1 == 0) {
    let y = malloc(2);
    free(x);
    *r = y;
    *y = vx;
    *(y + 1) = 0;
  } else {
    let v = *y1;
    if (vx <= v && v <= vx) {
      let n = *(y1 + 1);
      *r = n;
      unique01021201013(v, y1, r);
      free(x);
    } else {
      let n = *(y1 + 1);
      *r = n;
      *y1 = vx;
      unique01021201013(vx, y1, r);
      let y2 = *r;
      let y = malloc(2);
      free(x);
      *r = y;
      *y = v;
      *(y + 1) = y2;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/insert] sorted list: insert an element

[35m
[srtl/insert]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid srtl_insert(x loc, r loc) [k int]
{0 <= l ; r :-> k ** srtl(x, s, l)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], l + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 3778 milliseconds:[0m
[0mGoals generated: 693[0m
[0mGoals expanded: 643[0m
[0mAnd-nodes backtracked: 229[0m
[0mMaximum worklist size: 25[0m
[0mMaximum goal depth: 59[0m
[0mFinal memo size: (187,191,0)[0m
[0mFinal size of SMT cache: 380[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 40 times (186ms), failed 345 times (753ms)
AbduceBranch: succeeded 38 times (354ms), failed 26 times (39ms)
CheckPost: succeeded 45 times (104ms), failed 210 times (247ms)
Inconsistency: succeeded 13 times (38ms), failed 268 times (294ms)
SubstR: succeeded 112 times (66ms), failed 392 times (6ms)
[0m
[0mSMTSolving          2028ms
CyclicProofChecker  0ms   
                    2028ms[0m
[0mvoid srtl_insert (loc x, loc r) {
  let k = *r;
  if (x == 0) {
    let y = malloc(2);
    *r = y;
    *y = lower ([] ++ [k]);
    *(y + 1) = 0;
  } else {
    let v = *x;
    if (v <= k && k <= v) {
      let n = *(x + 1);
      srtl_insert(n, r);
      let y1 = *r;
      let y = malloc(2);
      free(x);
      *r = y;
      *(y + 1) = y1;
      *y = k;
    } else {
      if (v <= k) {
        let n = *(x + 1);
        srtl_insert(n, r);
        let y1 = *r;
        let y = malloc(2);
        free(x);
        *r = y;
        *(y + 1) = y1;
        *y = v;
      } else {
        let n = *(x + 1);
        *r = v;
        srtl_insert(n, r);
        let y1 = *r;
        let y = malloc(2);
        free(x);
        *r = y;
        *(y + 1) = y1;
        *y = k;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/insertion-sort] sorted list: insert an element

[35m
[srtl/insertion-sort]:[0m
[0m[0m
[34mvoid insertion_sort(x loc, r loc) []
{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_5>}
{r :-> y ** sll(x, s, n)<_alpha_6> ** srtl(y, s, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 2085 milliseconds:[0m
[0mGoals generated: 368[0m
[0mGoals expanded: 340[0m
[0mAnd-nodes backtracked: 214[0m
[0mMaximum worklist size: 26[0m
[0mMaximum goal depth: 58[0m
[0mFinal memo size: (190,67,0)[0m
[0mFinal size of SMT cache: 148[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 28 times (100ms), failed 195 times (603ms)
CheckPost: succeeded 29 times (76ms), failed 123 times (137ms)
Inconsistency: succeeded 0 times (0ms), failed 156 times (91ms)
SubstR: succeeded 89 times (57ms), failed 183 times (5ms)
Close: succeeded 19 times (61ms), failed 7 times (0ms)
[0m
[0mSMTSolving          1101ms
CyclicProofChecker  1ms   
                    1102ms[0m
[0mvoid insertion_sort (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    insertion_sort(n, r);
    let y = *r;
    *r = v;
    srtl_insert(y, r);
  }
}[0m
[0m-----------------------------------------------------[0m
[dll/copy] should be able to synthesize list copy

[35m
[dll/copy]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid dll_copy(r loc) []
{r :-> x ** dll(x, a, s)<_alpha_2>}
{r :-> y ** dll(x, a, s)<_alpha_3> ** dll(y, b, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 12761 milliseconds:[0m
[0mGoals generated: 5701[0m
[0mGoals expanded: 5571[0m
[0mAnd-nodes backtracked: 5355[0m
[0mMaximum worklist size: 115[0m
[0mMaximum goal depth: 82[0m
[0mFinal memo size: (3543,157,0)[0m
[0mFinal size of SMT cache: 1293[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 256 times (421ms), failed 3420 times (3745ms)
CheckPost: succeeded 1316 times (759ms), failed 404 times (62ms)
Read: succeeded 10 times (14ms), failed 2262 times (361ms)
SubstR: succeeded 1011 times (296ms), failed 2279 times (45ms)
*Partial: succeeded 137 times (57ms), failed 3278 times (264ms)
[0m
[0mSMTSolving          4786ms
CyclicProofChecker  0ms   
                    4786ms[0m
[0mvoid dll_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let vx = *x;
    let w = *(x + 1);
    let a = *(x + 2);
    *r = w;
    dll_copy(r);
    let y1 = *r;
    if (y1 == 0) {
      let y = malloc(3);
      *r = y;
      *y = vx;
      *(y + 1) = 0;
      *(y + 2) = a;
    } else {
      let v = *y1;
      let y = malloc(3);
      *(y1 + 2) = y;
      *r = y;
      *(y + 1) = y1;
      *(y + 2) = a;
      *y1 = vx;
      *y = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[dll/from-sll] should be able to convert a singly-linked list to a double-linked list

[35m
[dll/from-sll]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid sll_to_dll(f loc) []
{f :-> x ** sll(x, s)<_alpha_2>}
{f :-> i ** dll(i, 0, s)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 1888 milliseconds:[0m
[0mGoals generated: 269[0m
[0mGoals expanded: 238[0m
[0mAnd-nodes backtracked: 148[0m
[0mMaximum worklist size: 30[0m
[0mMaximum goal depth: 62[0m
[0mFinal memo size: (117,90,0)[0m
[0mFinal size of SMT cache: 185[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 18 times (84ms), failed 165 times (533ms)
CheckPost: succeeded 38 times (186ms), failed 36 times (66ms)
Inconsistency: succeeded 0 times (0ms), failed 177 times (150ms)
*Partial: succeeded 13 times (16ms), failed 146 times (43ms)
Read: succeeded 6 times (17ms), failed 110 times (27ms)
[0m
[0mSMTSolving          1125ms
CyclicProofChecker  0ms   
                    1125ms[0m
[0mvoid sll_to_dll (loc f) {
  let x = *f;
  if (x == 0) {
  } else {
    let vx = *x;
    let n = *(x + 1);
    *f = n;
    sll_to_dll(f);
    let i1 = *f;
    if (i1 == 0) {
      let i = malloc(3);
      free(x);
      *f = i;
      *i = vx;
      *(i + 1) = 0;
      *(i + 2) = 0;
    } else {
      let v = *i1;
      let i = malloc(3);
      free(x);
      *(i1 + 2) = i;
      *f = i;
      *(i + 1) = i1;
      *(i + 2) = 0;
      *i = v;
      *i1 = vx;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/size] should be able to synthesize tree size

[35m
[tree/size]:[0m
[0m[0m
[34mvoid tree_size(x loc, r loc) []
{0 <= n ; r :-> 0 ** treeN(x, n)<_alpha_6>}
{r :-> n ** treeN(x, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 2197 milliseconds:[0m
[0mGoals generated: 584[0m
[0mGoals expanded: 546[0m
[0mAnd-nodes backtracked: 403[0m
[0mMaximum worklist size: 39[0m
[0mMaximum goal depth: 56[0m
[0mFinal memo size: (266,62,0)[0m
[0mFinal size of SMT cache: 163[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 100 times (105ms), failed 224 times (341ms)
CheckPost: succeeded 27 times (123ms), failed 165 times (223ms)
Inconsistency: succeeded 0 times (0ms), failed 279 times (145ms)
*Partial: succeeded 2 times (2ms), failed 177 times (49ms)
SubstR: succeeded 73 times (42ms), failed 209 times (1ms)
[0m
[0mSMTSolving          1027ms
CyclicProofChecker  2ms   
                    1029ms[0m
[0mvoid tree_size (loc x, loc r) {
  if (x == 0) {
  } else {
    let l = *(x + 1);
    let rx = *(x + 2);
    tree_size(l, r);
    let n1 = *r;
    *r = 0;
    tree_size(rx, r);
    let n = *r;
    *r = 1 + n1 + n;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/free] should be able to deallocate a tree

[35m
[tree/free]:[0m
[0m[0m
[34mvoid tree_free(x loc) []
{tree(x, s)<_alpha_6>}
{emp}
[0m
[32mSuccessfully synthesised in 498 milliseconds:[0m
[0mGoals generated: 26[0m
[0mGoals expanded: 26[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 2[0m
[0mMaximum goal depth: 23[0m
[0mFinal memo size: (0,26,0)[0m
[0mFinal size of SMT cache: 18[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 14 times (95ms)
CheckPost: succeeded 0 times (0ms), failed 14 times (65ms)
Open: succeeded 1 times (28ms), failed 2 times (0ms)
*Partial: succeeded 0 times (0ms), failed 14 times (16ms)
Write: succeeded 0 times (0ms), failed 4 times (13ms)
[0m
[0mSMTSolving          300ms
CyclicProofChecker  0ms  
                    300ms[0m
[0mvoid tree_free (loc x) {
  if (x == 0) {
  } else {
    let l = *(x + 1);
    let r = *(x + 2);
    tree_free(l);
    tree_free(r);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-helper] should be able to flatten the tree into a list given an auxiliary function for list appending

[35m
[tree/flatten-helper]:[0m
[0m[0m
[34mvoid tree_flatten(z loc) []
{z :-> x ** tree(x, s)<_alpha_9>}
{z :-> y ** sll(y, s)<_alpha_10>}
[0m
[32mSuccessfully synthesised in 1248 milliseconds:[0m
[0mGoals generated: 141[0m
[0mGoals expanded: 123[0m
[0mAnd-nodes backtracked: 33[0m
[0mMaximum worklist size: 18[0m
[0mMaximum goal depth: 74[0m
[0mFinal memo size: (31,82,0)[0m
[0mFinal size of SMT cache: 84[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
CheckPost: succeeded 12 times (94ms), failed 48 times (128ms)
PostInconsistent: succeeded 4 times (11ms), failed 85 times (164ms)
Inconsistency: succeeded 0 times (0ms), failed 68 times (154ms)
*Partial: succeeded 4 times (7ms), failed 60 times (25ms)
SubstR: succeeded 27 times (22ms), failed 81 times (4ms)
[0m
[0mSMTSolving          682ms
CyclicProofChecker  0ms  
                    682ms[0m
[0mvoid tree_flatten (loc z) {
  let x = *z;
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    *z = l;
    tree_flatten(z);
    let y1 = *z;
    *z = r;
    tree_flatten(z);
    sll_append(y1, z);
    let y3 = *z;
    let y = malloc(2);
    free(x);
    *z = y;
    *(y + 1) = y3;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-acc] should be able to flatten the tree into a list given a list accumulator

[35m
[tree/flatten-acc]:[0m
[0m[0m
[34mvoid tree_flatten(x loc, z loc) []
{z :-> y ** sll(y, acc)<_alpha_7> ** tree(x, s)<_alpha_6>}
{s1 == s + acc ; z :-> t ** sll(t, s1)<_alpha_8>}
[0m
[32mSuccessfully synthesised in 1568 milliseconds:[0m
[0mGoals generated: 206[0m
[0mGoals expanded: 185[0m
[0mAnd-nodes backtracked: 50[0m
[0mMaximum worklist size: 14[0m
[0mMaximum goal depth: 71[0m
[0mFinal memo size: (45,122,0)[0m
[0mFinal size of SMT cache: 138[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 5 times (16ms), failed 132 times (296ms)
CheckPost: succeeded 22 times (126ms), failed 63 times (124ms)
Inconsistency: succeeded 0 times (0ms), failed 112 times (185ms)
*Partial: succeeded 7 times (5ms), failed 100 times (37ms)
SubstR: succeeded 40 times (37ms), failed 119 times (2ms)
[0m
[0mSMTSolving          872ms
CyclicProofChecker  0ms  
                    872ms[0m
[0mvoid tree_flatten (loc x, loc z) {
  let y = *z;
  if (y == 0) {
    tree_flatten00(x, z);
  } else {
    let n = *(y + 1);
    *z = n;
    tree_flatten(x, z);
    let t = *z;
    *z = y;
    *(y + 1) = t;
  }
}

void tree_flatten00 (loc x, loc z) {
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    tree_flatten00(l, z);
    tree_flatten(r, z);
    let t2 = *z;
    let t = malloc(2);
    free(x);
    *z = t;
    *t = v;
    *(t + 1) = t2;
  }
}[0m
[0m-----------------------------------------------------[0m
[bst/left-rotate] binary search tree: rotate left

[35m
[bst/left-rotate]:[0m
[0m[0m
[34mvoid bst_left_rotate(x loc, ret loc) []
{0 <= sz1 && 0 <= sz2 && not (r == 0) && v <= lower s2 && v == upper ([v] + s1) ; (x + 1) :-> l ** (x + 2) :-> r ** ret :-> unused ** x :-> v ** bst(l, s1, sz1)<_alpha_4> ** bst(r, s2, sz2)<_alpha_5> ** [x, 3]}
{sz3 + sz4 == sz1 + sz2 && upper s3 <= v3 && v3 == lower ([v3] + s4) ; (y + 1) :-> x ** (y + 2) :-> r3 ** ret :-> y ** y :-> v3 ** bst(r3, s4, sz4)<_alpha_7> ** bst(x, s3, sz3)<_alpha_6> ** [y, 3]}
[0m
[32mSuccessfully synthesised in 13670 milliseconds:[0m
[0mGoals generated: 2932[0m
[0mGoals expanded: 2892[0m
[0mAnd-nodes backtracked: 2827[0m
[0mMaximum worklist size: 44[0m
[0mMaximum goal depth: 63[0m
[0mFinal memo size: (1774,65,0)[0m
[0mFinal size of SMT cache: 1055[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 36 times (126ms), failed 1672 times (5236ms)
CheckPost: succeeded 1056 times (2407ms), failed 199 times (426ms)
Read: succeeded 10 times (21ms), failed 1316 times (340ms)
Inconsistency: succeeded 2 times (9ms), failed 1695 times (298ms)
*Partial: succeeded 25 times (43ms), failed 1634 times (228ms)
[0m
[0mSMTSolving  8035ms
            8035ms[0m
[0mvoid bst_left_rotate (loc x, loc ret) {
  let r = *(x + 2);
  let l = *(r + 1);
  *(r + 1) = x;
  *(x + 2) = l;
  *ret = r;
}[0m
[0m-----------------------------------------------------[0m
[bst/right-rotate] binary search tree: rotate right

[35m
[bst/right-rotate]:[0m
[0m[0m
[34mvoid bst_right_rotate(x loc, ret loc) []
{0 <= sz1 && 0 <= sz2 && not (l == 0) && upper s1 <= v && v == lower ([v] + s2) ; (x + 1) :-> l ** (x + 2) :-> r ** ret :-> unused ** x :-> v ** bst(l, s1, sz1)<_alpha_4> ** bst(r, s2, sz2)<_alpha_5> ** [x, 3]}
{sz3 + sz4 == sz1 + sz2 && v3 <= lower s4 && v3 == upper ([v3] + s3) ; (y + 1) :-> l3 ** (y + 2) :-> x ** ret :-> y ** y :-> v3 ** bst(l3, s3, sz3)<_alpha_6> ** bst(x, s4, sz4)<_alpha_7> ** [y, 3]}
[0m
[32mSuccessfully synthesised in 8151 milliseconds:[0m
[0mGoals generated: 1448[0m
[0mGoals expanded: 1406[0m
[0mAnd-nodes backtracked: 1337[0m
[0mMaximum worklist size: 45[0m
[0mMaximum goal depth: 63[0m
[0mFinal memo size: (898,65,0)[0m
[0mFinal size of SMT cache: 681[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 38 times (134ms), failed 862 times (3565ms)
CheckPost: succeeded 411 times (938ms), failed 87 times (304ms)
Inconsistency: succeeded 2 times (9ms), failed 897 times (313ms)
*Partial: succeeded 23 times (37ms), failed 836 times (176ms)
Read: succeeded 10 times (26ms), failed 590 times (185ms)
[0m
[0mSMTSolving  5098ms
            5098ms[0m
[0mvoid bst_right_rotate (loc x, loc ret) {
  let l = *(x + 1);
  let r = *(l + 2);
  *(l + 2) = x;
  *(x + 1) = r;
  *ret = l;
}[0m
[0m-----------------------------------------------------[0m
[bst/min] binary search tree: find smallest element

[0mGoals generated: 2026[0m
[0mGoals expanded: 1950[0m
[0mAnd-nodes backtracked: 1415[0m
[0mMaximum worklist size: 146[0m
[0mMaximum goal depth: 74[0m
[0mFinal memo size: (1192,8,467)[0m
[0mFinal size of SMT cache: 983[0m
[0mTime spent cycling: 6ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 33 times (176ms), failed 1156 times (5503ms)
CheckPost: succeeded 355 times (1077ms), failed 588 times (697ms)
SubstR: succeeded 472 times (307ms), failed 1156 times (30ms)
Inconsistency: succeeded 0 times (0ms), failed 790 times (283ms)
*Partial: succeeded 18 times (24ms), failed 739 times (184ms)
[0m
[0mSMTSolving          7564ms
CyclicProofChecker  3ms   
                    7567ms[0m
[bst/delete-root] binary search tree: delete root

[0mGoals generated: 1995[0m
[0mGoals expanded: 1955[0m
[0mAnd-nodes backtracked: 1729[0m
[0mMaximum worklist size: 45[0m
[0mMaximum goal depth: 103[0m
[0mFinal memo size: (1310,10,209)[0m
[0mFinal size of SMT cache: 852[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 48 times (194ms), failed 1177 times (6938ms)
CheckPost: succeeded 458 times (2230ms), failed 333 times (506ms)
SubstR: succeeded 476 times (322ms), failed 846 times (35ms)
*Partial: succeeded 44 times (56ms), failed 1000 times (196ms)
Inconsistency: succeeded 0 times (0ms), failed 1092 times (238ms)
[0m
[0mSMTSolving          9792ms
CyclicProofChecker  0ms   
                    9792ms[0m
[bst/to-srtl] flatten a BST into a sorted list

[35m
[bst/to-srtl]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid flatten(x loc, r loc) []
{0 <= n ; r :-> 0 ** bst(x, s, n)<_alpha_4>}
{r :-> y ** srtl(y, s, n)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 2812 milliseconds:[0m
[0mGoals generated: 340[0m
[0mGoals expanded: 320[0m
[0mAnd-nodes backtracked: 129[0m
[0mMaximum worklist size: 17[0m
[0mMaximum goal depth: 89[0m
[0mFinal memo size: (120,139,0)[0m
[0mFinal size of SMT cache: 224[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 11 times (37ms), failed 225 times (785ms)
CheckPost: succeeded 31 times (228ms), failed 102 times (379ms)
Inconsistency: succeeded 0 times (0ms), failed 191 times (241ms)
SubstR: succeeded 98 times (69ms), failed 170 times (2ms)
*Partial: succeeded 19 times (20ms), failed 161 times (48ms)
[0m
[0mSMTSolving          1729ms
CyclicProofChecker  0ms   
                    1729ms[0m
[0m{0 <= n ; r :-> 0 ** bst(x, s, n)<_alpha_4>}
{r :-> y ** srtl(y, s, n)<_alpha_5>}
void flatten (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let rx = *(x + 2);
    flatten(l, r);
    flatten121(rx, v, x, r);
  }
}

{0 <= 1 + sz1x + sz2x && 0 <= sz1x && 0 <= sz2x && _alpha_2x < _alpha_4 && _alpha_3x < _alpha_4 && not (r == 0) && not (r == x) && not (x == 0) && v == lower ([v] ++ s2x) && v == upper ([v] ++ s1x) ; (x + 1) :-> lx1 ** (x + 2) :-> rx ** r :-> y1 ** x :-> v ** bst(rx, s2x, sz2x)<_alpha_3x>[0,1] ** srtl(y1, s1x, sz1x)<_alpha_51>[1,0] ** [x, 3]}
{not (r == 0) ; r :-> y ** srtl(y, [v] ++ s1x ++ s2x, 1 + sz1x + sz2x)<_alpha_5>}
void flatten121 (loc rx, int v, loc x, loc r) {
  let y1 = *r;
  if (y1 == 0) {
    flatten(rx, r);
    let y2 = *r;
    let y = malloc(2);
    free(x);
    *r = y;
    *(y + 1) = y2;
    *y = v;
  } else {
    let n = *(y1 + 1);
    *r = n;
    flatten121(rx, v, x, r);
    let y = *r;
    *r = y1;
    *(y1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[rose-tree/free] should be able to deallocate a rose tree

[35m
[rose-tree/free]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid rose_tree_free(x loc) []
{rose_tree(x, s)<_alpha_7>}
{emp}
[0m
[32mSuccessfully synthesised in 692 milliseconds:[0m
[0mGoals generated: 47[0m
[0mGoals expanded: 45[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 5[0m
[0mMaximum goal depth: 39[0m
[0mFinal memo size: (0,45,0)[0m
[0mFinal size of SMT cache: 35[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 22 times (135ms)
CheckPost: succeeded 2 times (10ms), failed 24 times (103ms)
Open: succeeded 2 times (24ms), failed 2 times (0ms)
PostInconsistent: succeeded 0 times (0ms), failed 34 times (19ms)
*Partial: succeeded 1 times (1ms), failed 21 times (16ms)
[0m
[0mSMTSolving          418ms
CyclicProofChecker  0ms  
                    418ms[0m
[0m{rose_tree(x, s)<_alpha_7>}
{emp}
void rose_tree_free (loc x) {
  if (x == 0) {
  } else {
    rose_tree_free10(x);
  }
}

{_alpha_0x < _alpha_7 && not (x == 0) && s =i {vx} ++ s1x ; (x + 1) :-> bx ** x :-> vx ** buds(bx, s1x)<_alpha_0x>[0,1] ** [x, 2]}
{emp}
void rose_tree_free10 (loc x) {
  let b = *(x + 1);
  if (b == 0) {
    free(x);
  } else {
    let r = *b;
    rose_tree_free(r);
    rose_tree_free10(b);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[rose-tree/flatten] should be able to flatten a rose tree into a list

[0mGoals generated: 5410[0m
[0mGoals expanded: 5387[0m
[0mAnd-nodes backtracked: 5229[0m
[0mMaximum worklist size: 35[0m
[0mMaximum goal depth: 96[0m
[0mFinal memo size: (3130,29,125)[0m
[0mFinal size of SMT cache: 1333[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 280 times (585ms), failed 2552 times (2614ms)
CheckPost: succeeded 1796 times (2202ms), failed 502 times (415ms)
HeapUnifyPure: succeeded 1051 times (375ms), failed 1014 times (14ms)
Pick: succeeded 380 times (372ms), failed 12 times (0ms)
Inconsistency: succeeded 2 times (8ms), failed 2704 times (249ms)
[0m
[0mSMTSolving          5421ms
CyclicProofChecker  0ms   
                    5421ms[0m
[rose-tree/copy] should be able to copy a rose tree

[0mGoals generated: 3998[0m
[0mGoals expanded: 3748[0m
[0mAnd-nodes backtracked: 2559[0m
[0mMaximum worklist size: 297[0m
[0mMaximum goal depth: 65[0m
[0mFinal memo size: (1879,37,1109)[0m
[0mFinal size of SMT cache: 832[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 327 times (512ms), failed 2244 times (1997ms)
CheckPost: succeeded 437 times (677ms), failed 706 times (213ms)
SubstR: succeeded 938 times (339ms), failed 1511 times (19ms)
Close: succeeded 265 times (314ms), failed 95 times (1ms)
*Partial: succeeded 212 times (88ms), failed 1723 times (178ms)
[0m
[0mSMTSolving          3312ms
CyclicProofChecker  1ms   
                    3313ms[0m
[packed/unpack] 

[0mGoals generated: 2742[0m
[0mGoals expanded: 2473[0m
[0mAnd-nodes backtracked: 1237[0m
[0mMaximum worklist size: 370[0m
[0mMaximum goal depth: 95[0m
[0mFinal memo size: (1115,31,1094)[0m
[0mFinal size of SMT cache: 736[0m
[0mTime spent cycling: 5ms[0m
[0mExpensive rules:
CheckPost: succeeded 326 times (705ms), failed 1079 times (930ms)
PostInconsistent: succeeded 129 times (327ms), failed 1185 times (1301ms)
SubstR: succeeded 429 times (243ms), failed 1633 times (22ms)
Close: succeeded 139 times (237ms), failed 36 times (0ms)
Inconsistency: succeeded 0 times (0ms), failed 579 times (180ms)
[0m
[0mSMTSolving          3228ms
CyclicProofChecker  2ms   
                    3230ms[0m
