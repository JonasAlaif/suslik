[ints/swap] should be able to synthesize a swap program

[35m
[ints/swap]:[0m
[0m[0m
[34mvoid swap(x loc, y loc) []
{x :-> a ** y :-> b}
{x :-> b ** y :-> a}
[0m
[32mSuccessfully synthesised in 237 milliseconds:[0m
[0mGoals generated: 10[0m
[0mGoals expanded: 10[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 1[0m
[0mMaximum goal depth: 9[0m
[0mFinal memo size: (0,10,0)[0m
[0mFinal size of SMT cache: 6[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 7 times (31ms)
*Partial: succeeded 1 times (18ms), failed 9 times (7ms)
Write: succeeded 2 times (18ms), failed 1 times (1ms)
CheckPost: succeeded 1 times (13ms), failed 3 times (5ms)
Read: succeeded 2 times (7ms), failed 7 times (7ms)
[0m
[0mSMTSolving  228ms
            228ms[0m
[0mvoid swap (loc x, loc y) {
  let a = *x;
  let b = *y;
  *y = a;
  *x = b;
}[0m
[0m-----------------------------------------------------[0m
[sll/len] singly-linked list: length

[35m
[sll/len]:[0m
[0m[0m
[34mvoid sll_len(x loc, ret loc) []
{0 <= n ; ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{ret :-> n ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1271 milliseconds:[0m
[0mGoals generated: 154[0m
[0mGoals expanded: 143[0m
[0mAnd-nodes backtracked: 93[0m
[0mMaximum worklist size: 13[0m
[0mMaximum goal depth: 43[0m
[0mFinal memo size: (70,50,0)[0m
[0mFinal size of SMT cache: 101[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 10 times (57ms), failed 86 times (311ms)
CheckPost: succeeded 31 times (128ms), failed 27 times (31ms)
Inconsistency: succeeded 0 times (0ms), failed 93 times (82ms)
Read: succeeded 4 times (17ms), failed 93 times (22ms)
*Partial: succeeded 2 times (2ms), failed 97 times (34ms)
[0m
[0mSMTSolving          752ms
CyclicProofChecker  0ms  
                    752ms[0m
[0mvoid sll_len (loc x, loc ret) {
  if (x == 0) {
    *ret = 0;
  } else {
    let n = *(x + 1);
    sll_len(n, ret);
    let l = *ret;
    *ret = l + 1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/max] singly-linked list: max

[35m
[sll/max]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sll_max(x loc, ret loc) []
{ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{s == [] || m == upper s ; ret :-> m ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 7443 milliseconds:[0m
[0mGoals generated: 836[0m
[0mGoals expanded: 784[0m
[0mAnd-nodes backtracked: 515[0m
[0mMaximum worklist size: 26[0m
[0mMaximum goal depth: 71[0m
[0mFinal memo size: (334,221,0)[0m
[0mFinal size of SMT cache: 988[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 202 times (2802ms), failed 74 times (60ms)
PostInconsistent: succeeded 49 times (227ms), failed 456 times (2091ms)
Inconsistency: succeeded 7 times (18ms), failed 492 times (296ms)
Read: succeeded 9 times (18ms), failed 499 times (104ms)
*Partial: succeeded 10 times (8ms), failed 508 times (95ms)
[0m
[0mSMTSolving          5318ms
CyclicProofChecker  0ms   
                    5318ms[0m
[0mvoid sll_max (loc x, loc ret) {
  if (x == 0) {
    *ret = 0;
  } else {
    let vx = *x;
    let n = *(x + 1);
    sll_max(n, ret);
    let m = *ret;
    if (m <= vx && vx <= m) {
      *x = m;
    } else {
      if (vx <= m) {
        if (n == 0) {
          *ret = vx;
          *(x + 1) = 0;
        } else {
          let v = *n;
          if (v <= vx && vx <= m) {
            *n = m;
            *x = v;
          } else {
            *n = m;
          }
        }
      } else {
        *ret = vx;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/min] singly-linked list: min

[35m
[sll/min]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sll_min(x loc, ret loc) []
{ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{s == [] || m == lower s ; ret :-> m ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 7525 milliseconds:[0m
[0mGoals generated: 836[0m
[0mGoals expanded: 784[0m
[0mAnd-nodes backtracked: 515[0m
[0mMaximum worklist size: 26[0m
[0mMaximum goal depth: 71[0m
[0mFinal memo size: (334,221,0)[0m
[0mFinal size of SMT cache: 1000[0m
[0mTime spent cycling: 4ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 202 times (2877ms), failed 74 times (53ms)
PostInconsistent: succeeded 49 times (241ms), failed 456 times (2090ms)
Inconsistency: succeeded 7 times (17ms), failed 492 times (309ms)
Read: succeeded 9 times (19ms), failed 499 times (97ms)
*Partial: succeeded 10 times (6ms), failed 508 times (93ms)
[0m
[0mSMTSolving          5444ms
CyclicProofChecker  1ms   
                    5445ms[0m
[0mvoid sll_min (loc x, loc ret) {
  if (x == 0) {
    *ret = 0;
  } else {
    let vx = *x;
    let n = *(x + 1);
    sll_min(n, ret);
    let m = *ret;
    if (m <= vx && vx <= m) {
      *x = m;
    } else {
      if (m <= vx) {
        if (n == 0) {
          *ret = vx;
          *(x + 1) = 0;
        } else {
          let v = *n;
          if (m <= vx && vx <= v) {
            *n = m;
            *x = v;
          } else {
            *n = m;
          }
        }
      } else {
        *ret = vx;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/singleton] singly-linked list: construct a list with one element

[35m
[sll/singleton]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid sll_singleton(x int, ret loc) []
{ret :-> a}
{elems == {x} ; ret :-> y ** sll(y, elems)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 524 milliseconds:[0m
[0mGoals generated: 34[0m
[0mGoals expanded: 28[0m
[0mAnd-nodes backtracked: 5[0m
[0mMaximum worklist size: 7[0m
[0mMaximum goal depth: 22[0m
[0mFinal memo size: (5,23,0)[0m
[0mFinal size of SMT cache: 31[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 1 times (6ms), failed 22 times (104ms)
CheckPost: succeeded 4 times (54ms), failed 8 times (10ms)
Inconsistency: succeeded 0 times (0ms), failed 23 times (27ms)
*Partial: succeeded 3 times (5ms), failed 24 times (19ms)
Read: succeeded 1 times (11ms), failed 23 times (7ms)
[0m
[0mSMTSolving  348ms
            348ms[0m
[0mvoid sll_singleton (int x, loc ret) {
  let y = malloc(2);
  *ret = y;
  *(y + 1) = 0;
  *y = x;
}[0m
[0m-----------------------------------------------------[0m
[sll/copy] should be able to synthesize list copy

[35m
[sll/copy]:[0m
[0m[0m
[34mvoid sll_copy(r loc) []
{r :-> x ** sll(x, s)<a>}
{r :-> y ** sll(x, s)<a> ** sll(y, s)<b>}
[0m
[32mSuccessfully synthesised in 1349 milliseconds:[0m
[0mGoals generated: 169[0m
[0mGoals expanded: 153[0m
[0mAnd-nodes backtracked: 91[0m
[0mMaximum worklist size: 14[0m
[0mMaximum goal depth: 52[0m
[0mFinal memo size: (78,60,0)[0m
[0mFinal size of SMT cache: 95[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 12 times (83ms), failed 97 times (324ms)
CheckPost: succeeded 13 times (96ms), failed 18 times (14ms)
Inconsistency: succeeded 0 times (0ms), failed 107 times (69ms)
*Partial: succeeded 12 times (14ms), failed 111 times (47ms)
Close: succeeded 12 times (46ms), failed 6 times (0ms)
[0m
[0mSMTSolving          702ms
CyclicProofChecker  0ms  
                    702ms[0m
[0mvoid sll_copy (loc r) {
  let x = *r;
  if (x == 0) {
    *r = 0;
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    sll_copy(r);
    let y1 = *r;
    let y = malloc(2);
    *r = y;
    *(y + 1) = y1;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/append] singly-linked list: append

[35m
[sll/append]:[0m
[0m[0m
[34mvoid sll_append(x1 loc, ret loc) []
{ret :-> x2 ** sll(x1, s1)<_alpha_3> ** sll(x2, s2)<_alpha_4>}
{s == s1 + s2 ; ret :-> y ** sll(y, s)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 1333 milliseconds:[0m
[0mGoals generated: 169[0m
[0mGoals expanded: 144[0m
[0mAnd-nodes backtracked: 24[0m
[0mMaximum worklist size: 13[0m
[0mMaximum goal depth: 48[0m
[0mFinal memo size: (24,112,0)[0m
[0mFinal size of SMT cache: 105[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 5 times (26ms), failed 101 times (288ms)
Inconsistency: succeeded 0 times (0ms), failed 103 times (152ms)
CheckPost: succeeded 14 times (109ms), failed 33 times (20ms)
Read: succeeded 10 times (21ms), failed 103 times (26ms)
*Partial: succeeded 10 times (13ms), failed 113 times (33ms)
[0m
[0mSMTSolving          719ms
CyclicProofChecker  0ms  
                    719ms[0m
[0mvoid sll_append (loc x1, loc ret) {
  let x = *ret;
  if (x1 == 0) {
    if (x == 0) {
      *ret = 0;
    } else {
    }
  } else {
    let n = *(x1 + 1);
    sll_append(n, ret);
    let y = *ret;
    *ret = x1;
    *(x1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/delete-all] singly-linked list: delete all occurrences of x

[35m
[sll/delete-all]:[0m
[0mbranchAbduction = true[0m
[34mvoid sll_delete_all(x loc, ret loc) []
{ret :-> a ** sll(x, s)<_alpha_3>}
{s1 == s - {a} ; ret :-> y ** sll(y, s1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2546 milliseconds:[0m
[0mGoals generated: 357[0m
[0mGoals expanded: 348[0m
[0mAnd-nodes backtracked: 260[0m
[0mMaximum worklist size: 10[0m
[0mMaximum goal depth: 49[0m
[0mFinal memo size: (200,88,0)[0m
[0mFinal size of SMT cache: 310[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 28 times (83ms), failed 205 times (606ms)
AbduceBranch: succeeded 72 times (651ms), failed 40 times (31ms)
Inconsistency: succeeded 4 times (13ms), failed 227 times (177ms)
*Partial: succeeded 8 times (4ms), failed 236 times (48ms)
Read: succeeded 5 times (14ms), failed 231 times (32ms)
[0m
[0mSMTSolving          1587ms
CyclicProofChecker  0ms   
                    1587ms[0m
[0mvoid sll_delete_all (loc x, loc ret) {
  let a = *ret;
  if (x == 0) {
    *ret = 0;
  } else {
    let v = *x;
    let n = *(x + 1);
    if (a <= v && v <= a) {
      sll_delete_all(n, ret);
      free(x);
    } else {
      sll_delete_all(n, ret);
      let y = *ret;
      *ret = x;
      *(x + 1) = y;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/multi-append] append multiple lists

[35m
[sll/multi-append]:[0m
[0m[0m
[34mvoid append3(x loc, y loc, z loc, r loc) []
{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
[0m
[32mSuccessfully synthesised in 2665 milliseconds:[0m
[0mGoals generated: 664[0m
[0mGoals expanded: 521[0m
[0mAnd-nodes backtracked: 72[0m
[0mMaximum worklist size: 38[0m
[0mMaximum goal depth: 70[0m
[0mFinal memo size: (72,409,0)[0m
[0mFinal size of SMT cache: 276[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 16 times (56ms), failed 283 times (560ms)
Inconsistency: succeeded 0 times (0ms), failed 264 times (372ms)
CheckPost: succeeded 39 times (219ms), failed 128 times (74ms)
SubstR: succeeded 125 times (55ms), failed 260 times (4ms)
Read: succeeded 35 times (30ms), failed 264 times (28ms)
[0m
[0mSMTSolving          1397ms
CyclicProofChecker  0ms   
                    1397ms[0m
[0m{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
void append3 (loc x, loc y, loc z, loc r) {
  if (x == 0) {
    append300(y, z, r);
  } else {
    let n = *(x + 1);
    append3(n, y, z, r);
    let v = *r;
    *r = x;
    *(x + 1) = v;
  }
}

{not (r == 0) && s1 =i {} && x == 0 ; r :-> a1 ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{not (r == 0) ; r :-> v ** sll(v, s1 ++ s2 ++ s3)<_alpha_6>}
void append300 (loc y, loc z, loc r) {
  if (y == 0) {
    append30100(z, r);
  } else {
    let n = *(y + 1);
    append300(n, z, r);
    let v = *r;
    *r = y;
    *(y + 1) = v;
  }
}

{not (r == 0) && s2 =i {} && x == 0 && y == 0 ; r :-> a1 ** sll(z, s3)<_alpha_5>}
{not (r == 0) ; r :-> v ** sll(v, {} ++ s2 ++ s3)<_alpha_6>}
void append30100 (loc z, loc r) {
  if (z == 0) {
    *r = 0;
  } else {
    let n = *(z + 1);
    append30100(n, r);
    let v1 = *r;
    append30100(v1, r);
    let v = *r;
    *r = z;
    *(z + 1) = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/union] union of two unique lists

[0mGoals generated: 4052[0m
[0mGoals expanded: 3989[0m
[0mAnd-nodes backtracked: 3529[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 76[0m
[0mFinal memo size: (2198,285,174)[0m
[0mFinal size of SMT cache: 1839[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 410 times (685ms), failed 1980 times (3194ms)
AbduceBranch: succeeded 1174 times (3429ms), failed 370 times (166ms)
Inconsistency: succeeded 6 times (22ms), failed 2380 times (534ms)
Pick: succeeded 485 times (452ms), failed 925 times (27ms)
Read: succeeded 25 times (22ms), failed 2386 times (342ms)
[0m
[0mSMTSolving          7147ms
CyclicProofChecker  0ms   
                    7147ms[0m
[sll/diff] difference of two unique lists

[35m
[sll/diff]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid diff(r loc, y loc) []
{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 - s2)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 12749 milliseconds:[0m
[0mGoals generated: 2756[0m
[0mGoals expanded: 2712[0m
[0mAnd-nodes backtracked: 2377[0m
[0mMaximum worklist size: 25[0m
[0mMaximum goal depth: 98[0m
[0mFinal memo size: (1749,274,0)[0m
[0mFinal size of SMT cache: 1681[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 320 times (826ms), failed 1335 times (3095ms)
AbduceBranch: succeeded 564 times (2630ms), failed 275 times (185ms)
Inconsistency: succeeded 9 times (27ms), failed 1617 times (526ms)
CheckPost: succeeded 53 times (289ms), failed 78 times (62ms)
Pick: succeeded 304 times (278ms), failed 428 times (8ms)
[0m
[0mSMTSolving          7032ms
CyclicProofChecker  0ms   
                    7032ms[0m
[0m{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 - s2)<_alpha_5>}
void diff (loc r, loc y) {
  let x = *r;
  if (y == 0) {
    if (x == 0) {
      *r = 0;
    } else {
    }
  } else {
    let v = *y;
    let n = *(y + 1);
    diff(r, n);
    diff0213018(v, r, y);
  }
}

{_alpha_1y < _alpha_4 && not (r == 0) && not (r == y) && not (vy in s1y) && not (y == 0) && true ; (y + 1) :-> nxty1 ** r :-> z1 ** y :-> vy ** ulist(z1, s1 -- s1y)<_alpha_51>[1,0] ** [y, 2]}
{not (r == 0) ; r :-> z ** ulist(z, s1 -- ({vy} ++ s1y))<_alpha_5>}
void diff0213018 (int vy, loc r, loc y) {
  let z1 = *r;
  if (z1 == 0) {
    free(y);
    *r = 0;
  } else {
    let v = *z1;
    let n = *(z1 + 1);
    if (vy <= v && v <= vy) {
      *r = n;
      diff0213018(v, r, z1);
      free(y);
    } else {
      *r = n;
      *z1 = vy;
      diff0213018(vy, r, z1);
      let z = *r;
      *r = y;
      *(y + 1) = z;
      *y = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/unique] deduplicate a list

[35m
[sll/unique]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid unique(r loc) []
{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 10385 milliseconds:[0m
[0mGoals generated: 2886[0m
[0mGoals expanded: 2870[0m
[0mAnd-nodes backtracked: 2685[0m
[0mMaximum worklist size: 18[0m
[0mMaximum goal depth: 92[0m
[0mFinal memo size: (1615,164,0)[0m
[0mFinal size of SMT cache: 1419[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 899 times (3021ms), failed 222 times (114ms)
PostInconsistent: succeeded 317 times (442ms), failed 1322 times (1922ms)
Pick: succeeded 372 times (318ms), failed 684 times (12ms)
Inconsistency: succeeded 8 times (18ms), failed 1632 times (281ms)
Read: succeeded 10 times (17ms), failed 1640 times (199ms)
[0m
[0mSMTSolving          5170ms
CyclicProofChecker  0ms   
                    5170ms[0m
[0m{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
void unique (loc r) {
  let x = *r;
  if (x == 0) {
    *r = 0;
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    unique(r);
    unique0213013(v, x, r);
  }
}

{_alpha_0x1 < _alpha_3 && not (r == 0) && not (r == x) && not (x == 0) && true ; (x + 1) :-> nxtx11 ** r :-> y1 ** x :-> vx ** ulist(y1, s1x1)<_alpha_41>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** ulist(y, {vx} ++ s1x1)<_alpha_4>}
void unique0213013 (int vx, loc x, loc r) {
  let y1 = *r;
  if (y1 == 0) {
    *r = x;
    *(x + 1) = 0;
  } else {
    let v = *y1;
    let n = *(y1 + 1);
    if (vx <= v && v <= vx) {
      free(x);
      *y1 = vx;
    } else {
      *r = n;
      *y1 = vx;
      unique0213013(vx, y1, r);
      let y = *r;
      *r = x;
      *(x + 1) = y;
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/prepend] sorted list: prepend an element

[35m
[srtl/prepend]:[0m
[0m[0m
[34mvoid srtl_prepend(x loc, k int, r loc) []
{0 <= n && k == lower (s + [k]) ; r :-> a ** srtl(x, s, n)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], n + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 616 milliseconds:[0m
[0mGoals generated: 34[0m
[0mGoals expanded: 31[0m
[0mAnd-nodes backtracked: 4[0m
[0mMaximum worklist size: 4[0m
[0mMaximum goal depth: 26[0m
[0mFinal memo size: (3,27,0)[0m
[0mFinal size of SMT cache: 29[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 2 times (25ms), failed 24 times (112ms)
CheckPost: succeeded 4 times (56ms), failed 9 times (19ms)
Inconsistency: succeeded 0 times (0ms), failed 26 times (39ms)
Read: succeeded 1 times (13ms), failed 26 times (9ms)
FrameUnfold: succeeded 1 times (2ms), failed 2 times (17ms)
[0m
[0mSMTSolving  404ms
            404ms[0m
[0mvoid srtl_prepend (loc x, int k, loc r) {
  let y = malloc(2);
  *r = y;
  *(y + 1) = x;
  *y = k;
}[0m
[0m-----------------------------------------------------[0m
[srtl/insertion-sort] sorted list: insert an element

[35m
[srtl/insertion-sort]:[0m
[0m[0m
[34mvoid insertion_sort(x loc, r loc) []
{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_5>}
{r :-> y ** sll(x, s, n)<_alpha_6> ** srtl(y, s, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 1705 milliseconds:[0m
[0mGoals generated: 240[0m
[0mGoals expanded: 219[0m
[0mAnd-nodes backtracked: 131[0m
[0mMaximum worklist size: 19[0m
[0mMaximum goal depth: 58[0m
[0mFinal memo size: (109,67,0)[0m
[0mFinal size of SMT cache: 106[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 25 times (114ms), failed 112 times (536ms)
CheckPost: succeeded 13 times (68ms), failed 27 times (28ms)
Inconsistency: succeeded 0 times (0ms), failed 129 times (79ms)
*Partial: succeeded 14 times (17ms), failed 134 times (44ms)
Close: succeeded 18 times (55ms), failed 7 times (0ms)
[0m
[0mSMTSolving          939ms
CyclicProofChecker  0ms  
                    939ms[0m
[0mvoid insertion_sort (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    insertion_sort(n, r);
    let y = *r;
    *r = v;
    srtl_insert(y, r);
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/sort] sort a list

[35m
[srtl/sort]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sort(x loc) []
{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 4174 milliseconds:[0m
[0mGoals generated: 522[0m
[0mGoals expanded: 508[0m
[0mAnd-nodes backtracked: 349[0m
[0mMaximum worklist size: 11[0m
[0mMaximum goal depth: 64[0m
[0mFinal memo size: (246,146,0)[0m
[0mFinal size of SMT cache: 429[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 31 times (138ms), failed 307 times (1173ms)
AbduceBranch: succeeded 120 times (1022ms), failed 60 times (56ms)
Inconsistency: succeeded 6 times (16ms), failed 331 times (225ms)
Read: succeeded 6 times (6ms), failed 337 times (69ms)
*Partial: succeeded 8 times (6ms), failed 343 times (59ms)
[0m
[0mSMTSolving          2643ms
CyclicProofChecker  0ms   
                    2643ms[0m
[0m{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
void sort (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    sort(n);
    sort0012013(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_0x < _alpha_3 && not (x == 0) && true ; (x + 1) :-> nx ** x :-> vx ** srtl(nx, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{srtl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void sort0012013 (loc nx, int vx, loc x) {
  if (nx == 0) {
    *(x + 1) = 0;
    *x = lower ([vx] ++ []);
  } else {
    let v = *nx;
    let n = *(nx + 1);
    if (vx <= v) {
      if (v <= vx) {
        *x = v;
      } else {
      }
    } else {
      *nx = vx;
      sort0012013(n, vx, nx);
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[dll/copy] should be able to synthesize list copy

[0mGoals generated: 8212[0m
[0mGoals expanded: 8181[0m
[0mAnd-nodes backtracked: 8040[0m
[0mMaximum worklist size: 69[0m
[0mMaximum goal depth: 66[0m
[0mFinal memo size: (4647,52,78)[0m
[0mFinal size of SMT cache: 960[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 87 times (251ms), failed 4512 times (3142ms)
CheckPost: succeeded 3119 times (969ms), failed 482 times (38ms)
Read: succeeded 15 times (16ms), failed 4599 times (746ms)
Pick: succeeded 1193 times (474ms), failed 2335 times (34ms)
*Partial: succeeded 107 times (27ms), failed 4614 times (291ms)
[0m
[0mSMTSolving          3896ms
CyclicProofChecker  0ms   
                    3896ms[0m
[dll/from-sll] should be able to convert a singly-linked list to a double-linked list

[35m
[dll/from-sll]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid sll_to_dll(f loc) []
{f :-> x ** sll(x, s)<_alpha_2>}
{f :-> i ** dll(i, 0, s)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 1655 milliseconds:[0m
[0mGoals generated: 225[0m
[0mGoals expanded: 199[0m
[0mAnd-nodes backtracked: 107[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 62[0m
[0mFinal memo size: (89,92,0)[0m
[0mFinal size of SMT cache: 139[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 8 times (50ms), failed 134 times (481ms)
CheckPost: succeeded 33 times (161ms), failed 38 times (37ms)
Inconsistency: succeeded 0 times (0ms), failed 140 times (110ms)
*Partial: succeeded 13 times (15ms), failed 146 times (53ms)
Read: succeeded 6 times (16ms), failed 140 times (27ms)
[0m
[0mSMTSolving          934ms
CyclicProofChecker  0ms  
                    934ms[0m
[0mvoid sll_to_dll (loc f) {
  let x = *f;
  if (x == 0) {
    *f = 0;
  } else {
    let vx = *x;
    let n = *(x + 1);
    *f = n;
    sll_to_dll(f);
    let i1 = *f;
    if (i1 == 0) {
      let i = malloc(3);
      free(x);
      *f = i;
      *i = vx;
      *(i + 1) = 0;
      *(i + 2) = 0;
    } else {
      let v = *i1;
      let i = malloc(3);
      free(x);
      *(i1 + 2) = i;
      *f = i;
      *(i + 1) = i1;
      *(i + 2) = 0;
      *i = v;
      *i1 = vx;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[multi-list/free] should be able to deallocate a multi-list

[35m
[multi-list/free]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid multilist_free(x loc) []
{multilist(x, len, s)<_alpha_3>}
{emp}
[0m
[32mSuccessfully synthesised in 724 milliseconds:[0m
[0mGoals generated: 54[0m
[0mGoals expanded: 52[0m
[0mAnd-nodes backtracked: 2[0m
[0mMaximum worklist size: 6[0m
[0mMaximum goal depth: 42[0m
[0mFinal memo size: (2,50,0)[0m
[0mFinal size of SMT cache: 31[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 21 times (169ms)
CheckPost: succeeded 3 times (26ms), failed 15 times (68ms)
Open: succeeded 3 times (32ms), failed 1 times (0ms)
*Partial: succeeded 1 times (2ms), failed 25 times (17ms)
SubstL: succeeded 12 times (17ms), failed 9 times (1ms)
[0m
[0mSMTSolving          437ms
CyclicProofChecker  0ms  
                    437ms[0m
[0m{multilist(x, len, s)<_alpha_3>}
{emp}
void multilist_free (loc x) {
  if (x == 0) {
  } else {
    let h = *x;
    let t = *(x + 1);
    multilist_free(t);
    multilist_free114(h, x);
  }
}

{_alpha_1x < _alpha_3 && _alpha_2x < _alpha_3 && not (x == 0) ; (x + 1) :-> tx1 ** x :-> h ** sll(h, len1x, s1x)<_alpha_1x>[0,1] ** [x, 2]}
{emp}
void multilist_free114 (loc h, loc x) {
  if (h == 0) {
    free(x);
  } else {
    let n = *(h + 1);
    *h = n;
    multilist_free114(n, h);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/free2] Deallocate two trees

[35m
[tree/free2]:[0m
[0m[0m
[34mvoid treefree2(x loc, y loc) []
{tree(x, s1)<_alpha_6> ** tree(y, s2)<_alpha_7>}
{emp}
[0m
[32mSuccessfully synthesised in 1160 milliseconds:[0m
[0mGoals generated: 213[0m
[0mGoals expanded: 209[0m
[0mAnd-nodes backtracked: 58[0m
[0mMaximum worklist size: 10[0m
[0mMaximum goal depth: 43[0m
[0mFinal memo size: (54,99,0)[0m
[0mFinal size of SMT cache: 45[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 57 times (315ms)
Open: succeeded 7 times (39ms), failed 8 times (1ms)
SubstR: succeeded 72 times (35ms), failed 95 times (2ms)
Read: succeeded 18 times (24ms), failed 57 times (12ms)
CheckPost: succeeded 0 times (0ms), failed 59 times (36ms)
[0m
[0mSMTSolving          500ms
CyclicProofChecker  1ms  
                    501ms[0m
[0mvoid treefree2 (loc x, loc y) {
  if (x == 0) {
    if (y == 0) {
    } else {
      let l = *(y + 1);
      let r = *(y + 2);
      treefree2(l, r);
      free(y);
    }
  } else {
    let lx = *(x + 1);
    let rx = *(x + 2);
    treefree2(lx, rx);
    if (y == 0) {
      free(x);
    } else {
      let l = *(y + 1);
      let r = *(y + 2);
      treefree2(l, r);
      free(y);
      free(x);
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-helper] should be able to flatten the tree into a list given an auxiliary function for list appending

[35m
[tree/flatten-helper]:[0m
[0m[0m
[34mvoid tree_flatten(z loc) []
{z :-> x ** tree(x, s)<_alpha_9>}
{z :-> y ** sll(y, s)<_alpha_10>}
[0m
[32mSuccessfully synthesised in 1057 milliseconds:[0m
[0mGoals generated: 130[0m
[0mGoals expanded: 118[0m
[0mAnd-nodes backtracked: 36[0m
[0mMaximum worklist size: 17[0m
[0mMaximum goal depth: 75[0m
[0mFinal memo size: (33,82,0)[0m
[0mFinal size of SMT cache: 60[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 5 times (17ms), failed 61 times (162ms)
Inconsistency: succeeded 0 times (0ms), failed 59 times (117ms)
CheckPost: succeeded 11 times (88ms), failed 27 times (17ms)
Read: succeeded 7 times (21ms), failed 59 times (16ms)
*Partial: succeeded 7 times (8ms), failed 66 times (28ms)
[0m
[0mSMTSolving          540ms
CyclicProofChecker  0ms  
                    540ms[0m
[0mvoid tree_flatten (loc z) {
  let x = *z;
  if (x == 0) {
    *z = 0;
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    *z = l;
    tree_flatten(z);
    let y1 = *z;
    *z = r;
    tree_flatten(z);
    sll_append(y1, z);
    let y3 = *z;
    let y = malloc(2);
    free(x);
    *z = y;
    *(y + 1) = y3;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-acc] should be able to flatten the tree into a list given a list accumulator

[35m
[tree/flatten-acc]:[0m
[0m[0m
[34mvoid tree_flatten(x loc, z loc) []
{z :-> y ** sll(y, acc)<_alpha_7> ** tree(x, s)<_alpha_6>}
{s1 == s + acc ; z :-> t ** sll(t, s1)<_alpha_8>}
[0m
[32mSuccessfully synthesised in 1733 milliseconds:[0m
[0mGoals generated: 280[0m
[0mGoals expanded: 251[0m
[0mAnd-nodes backtracked: 60[0m
[0mMaximum worklist size: 16[0m
[0mMaximum goal depth: 71[0m
[0mFinal memo size: (57,181,0)[0m
[0mFinal size of SMT cache: 144[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 9 times (49ms), failed 138 times (328ms)
Inconsistency: succeeded 0 times (0ms), failed 135 times (227ms)
CheckPost: succeeded 24 times (158ms), failed 56 times (40ms)
*Partial: succeeded 15 times (13ms), failed 151 times (37ms)
Read: succeeded 16 times (22ms), failed 135 times (23ms)
[0m
[0mSMTSolving          929ms
CyclicProofChecker  0ms  
                    929ms[0m
[0mvoid tree_flatten (loc x, loc z) {
  let y = *z;
  if (y == 0) {
    tree_flatten00(x, z);
  } else {
    let n = *(y + 1);
    *z = n;
    tree_flatten(x, z);
    let t = *z;
    *z = y;
    *(y + 1) = t;
  }
}

void tree_flatten00 (loc x, loc z) {
  if (x == 0) {
    *z = 0;
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    tree_flatten00(l, z);
    tree_flatten(r, z);
    let t2 = *z;
    let t = malloc(2);
    free(x);
    *z = t;
    *t = v;
    *(t + 1) = t2;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten] should be able to flatten the tree into a list

[35m
[tree/flatten]:[0m
[0m[0m
[34mvoid flatten(z loc) []
{z :-> x ** tree(x, s)<_alpha_6>}
{z :-> y ** sll(y, s)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 2312 milliseconds:[0m
[0mGoals generated: 486[0m
[0mGoals expanded: 431[0m
[0mAnd-nodes backtracked: 124[0m
[0mMaximum worklist size: 41[0m
[0mMaximum goal depth: 95[0m
[0mFinal memo size: (111,246,0)[0m
[0mFinal size of SMT cache: 181[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 23 times (74ms), failed 233 times (410ms)
CheckPost: succeeded 46 times (253ms), failed 88 times (56ms)
Inconsistency: succeeded 0 times (0ms), failed 238 times (226ms)
*Partial: succeeded 34 times (25ms), failed 261 times (45ms)
Read: succeeded 23 times (26ms), failed 238 times (39ms)
[0m
[0mSMTSolving          1123ms
CyclicProofChecker  0ms   
                    1123ms[0m
[0m{z :-> x ** tree(x, s)<_alpha_6>}
{z :-> y ** sll(y, s)<_alpha_7>}
void flatten (loc z) {
  let x = *z;
  if (x == 0) {
    *z = 0;
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    *z = l;
    flatten(z);
    let y = *z;
    *z = r;
    flatten(z);
    flatten130(y, v, x, z);
  }
}

{_alpha_1x1 < _alpha_6 && _alpha_2x1 < _alpha_6 && not (x == 0) && not (x == z) && not (z == 0) ; (x + 1) :-> lx11 ** (x + 2) :-> rx11 ** x :-> v ** z :-> y2 ** sll(y1, s1x1)<_alpha_71>[1,0] ** sll(y2, s2x1)<_alpha_72>[1,0] ** [x, 3]}
{not (z == 0) ; z :-> y ** sll(y, {v} ++ s1x1 ++ s2x1)<_alpha_7>}
void flatten130 (loc y1, int v, loc x, loc z) {
  let y2 = *z;
  if (y1 == 0) {
    let y = malloc(2);
    free(x);
    *z = y;
    *y = v;
    *(y + 1) = y2;
  } else {
    let n = *(y1 + 1);
    flatten130(n, v, x, z);
    let y = *z;
    *z = y1;
    *(y1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-dll-linear] flatten a tree into a doubly-linked list in learn time

[0mGoals generated: 4154[0m
[0mGoals expanded: 3946[0m
[0mAnd-nodes backtracked: 3109[0m
[0mMaximum worklist size: 76[0m
[0mMaximum goal depth: 97[0m
[0mFinal memo size: (2239,557,271)[0m
[0mFinal size of SMT cache: 1371[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 117 times (260ms), failed 2361 times (3858ms)
CheckPost: succeeded 1011 times (1363ms), failed 480 times (407ms)
Inconsistency: succeeded 7 times (18ms), failed 2427 times (633ms)
Read: succeeded 73 times (25ms), failed 2434 times (405ms)
Pick: succeeded 235 times (313ms), failed 1073 times (19ms)
[0m
[0mSMTSolving          6111ms
CyclicProofChecker  0ms   
                    6111ms[0m
[bst/right-rotate] binary search tree: rotate right

[35m
[bst/right-rotate]:[0m
[0m[0m
[34mvoid bst_right_rotate(x loc, ret loc) []
{0 <= sz1 && 0 <= sz2 && not (l == 0) && upper s1 <= v && v == lower ([v] + s2) ; (x + 1) :-> l ** (x + 2) :-> r ** ret :-> unused ** x :-> v ** bst(l, s1, sz1)<_alpha_4> ** bst(r, s2, sz2)<_alpha_5> ** [x, 3]}
{sz3 + sz4 == sz1 + sz2 && v3 <= lower s4 && v3 == upper ([v3] + s3) ; (y + 1) :-> l3 ** (y + 2) :-> x ** ret :-> y ** y :-> v3 ** bst(l3, s3, sz3)<_alpha_6> ** bst(x, s4, sz4)<_alpha_7> ** [y, 3]}
[0m
[32mSuccessfully synthesised in 10761 milliseconds:[0m
[0mGoals generated: 2082[0m
[0mGoals expanded: 2057[0m
[0mAnd-nodes backtracked: 1969[0m
[0mMaximum worklist size: 31[0m
[0mMaximum goal depth: 64[0m
[0mFinal memo size: (1193,63,0)[0m
[0mFinal size of SMT cache: 855[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 22 times (144ms), failed 1166 times (4472ms)
CheckPost: succeeded 795 times (1992ms), failed 81 times (75ms)
Read: succeeded 10 times (20ms), failed 1188 times (359ms)
Pick: succeeded 198 times (231ms), failed 643 times (21ms)
Inconsistency: succeeded 2 times (10ms), failed 1186 times (200ms)
[0m
[0mSMTSolving  6541ms
            6541ms[0m
[0mvoid bst_right_rotate (loc x, loc ret) {
  let l = *(x + 1);
  let r = *(l + 2);
  *(l + 2) = x;
  *(x + 1) = r;
  *ret = l;
}[0m
[0m-----------------------------------------------------[0m
[bst/min] binary search tree: find smallest element

[0mGoals generated: 2225[0m
[0mGoals expanded: 2167[0m
[0mAnd-nodes backtracked: 1820[0m
[0mMaximum worklist size: 99[0m
[0mMaximum goal depth: 67[0m
[0mFinal memo size: (1110,7,298)[0m
[0mFinal size of SMT cache: 1142[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 13 times (58ms), failed 1127 times (6485ms)
CheckPost: succeeded 784 times (2753ms), failed 191 times (72ms)
Pick: succeeded 225 times (253ms), failed 601 times (23ms)
Read: succeeded 14 times (17ms), failed 1074 times (228ms)
*Partial: succeeded 8 times (10ms), failed 1088 times (164ms)
[0m
[0mSMTSolving          9119ms
CyclicProofChecker  1ms   
                    9120ms[0m
[bst/max] binary search tree: find smallest element

[0mGoals generated: 2105[0m
[0mGoals expanded: 2045[0m
[0mAnd-nodes backtracked: 1780[0m
[0mMaximum worklist size: 92[0m
[0mMaximum goal depth: 67[0m
[0mFinal memo size: (1070,7,233)[0m
[0mFinal size of SMT cache: 1120[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 11 times (53ms), failed 1102 times (6616ms)
CheckPost: succeeded 764 times (2792ms), failed 146 times (78ms)
Pick: succeeded 223 times (249ms), failed 582 times (23ms)
Read: succeeded 12 times (19ms), failed 1068 times (216ms)
SubstR: succeeded 230 times (157ms), failed 1055 times (20ms)
[0m
[0mSMTSolving          9251ms
CyclicProofChecker  0ms   
                    9251ms[0m
[bst/to-srtl] flatten a BST into a sorted list

[35m
[bst/to-srtl]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid flatten(x loc, r loc) []
{0 <= n ; r :-> 0 ** bst(x, s, n)<_alpha_4>}
{r :-> y ** srtl(y, s, n)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 11540 milliseconds:[0m
[0mGoals generated: 2334[0m
[0mGoals expanded: 2213[0m
[0mAnd-nodes backtracked: 1563[0m
[0mMaximum worklist size: 38[0m
[0mMaximum goal depth: 109[0m
[0mFinal memo size: (1090,551,0)[0m
[0mFinal size of SMT cache: 959[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 79 times (247ms), failed 1257 times (3228ms)
CheckPost: succeeded 606 times (2168ms), failed 304 times (252ms)
Inconsistency: succeeded 3 times (6ms), failed 1303 times (561ms)
Read: succeeded 43 times (23ms), failed 1306 times (292ms)
Pick: succeeded 180 times (224ms), failed 532 times (10ms)
[0m
[0mSMTSolving          6071ms
CyclicProofChecker  0ms   
                    6071ms[0m
[0m{0 <= n ; r :-> 0 ** bst(x, s, n)<_alpha_4>}
{r :-> y ** srtl(y, s, n)<_alpha_5>}
void flatten (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let rx = *(x + 2);
    flatten(l, r);
    let y = *r;
    *r = 0;
    flatten(rx, r);
    flatten135(y, v, x, r);
  }
}

{0 <= 1 + sz1x + sz2x && 0 <= sz1x && 0 <= sz2x && _alpha_2x < _alpha_4 && _alpha_3x < _alpha_4 && not (r == 0) && not (r == x) && not (x == 0) && vx == lower ([vx] ++ s2x) && vx == upper ([vx] ++ s1x) ; (x + 1) :-> lx1 ** (x + 2) :-> rx1 ** r :-> y2 ** x :-> vx ** srtl(y1, s1x, sz1x)<_alpha_51>[1,0] ** srtl(y2, s2x, sz2x)<_alpha_52>[1,0] ** [x, 3]}
{not (r == 0) ; r :-> y ** srtl(y, [vx] ++ s1x ++ s2x, 1 + sz1x + sz2x)<_alpha_5>}
void flatten135 (loc y1, int vx, loc x, loc r) {
  let y2 = *r;
  if (y1 == 0) {
    if (y2 == 0) {
      let y = malloc(2);
      free(x);
      *r = y;
      *y = lower ([vx] ++ [] ++ []);
      *(y + 1) = 0;
    } else {
      let v = *y2;
      let nx = *(y2 + 1);
      let n = malloc(2);
      free(x);
      *(y2 + 1) = n;
      *n = v;
      *(n + 1) = nx;
      *y2 = vx;
    }
  } else {
    let n = *(y1 + 1);
    flatten135(n, vx, x, r);
    let y = *r;
    *r = y1;
    *(y1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[rose-tree/free] should be able to deallocate a rose tree

[35m
[rose-tree/free]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid rose_tree_free(x loc) []
{rose_tree(x, s)<_alpha_7>}
{emp}
[0m
[32mSuccessfully synthesised in 651 milliseconds:[0m
[0mGoals generated: 47[0m
[0mGoals expanded: 45[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 5[0m
[0mMaximum goal depth: 39[0m
[0mFinal memo size: (0,45,0)[0m
[0mFinal size of SMT cache: 23[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 17 times (122ms)
CheckPost: succeeded 2 times (14ms), failed 15 times (52ms)
Open: succeeded 2 times (23ms), failed 2 times (0ms)
PostInconsistent: succeeded 0 times (0ms), failed 23 times (21ms)
*Partial: succeeded 1 times (2ms), failed 21 times (17ms)
[0m
[0mSMTSolving          348ms
CyclicProofChecker  0ms  
                    348ms[0m
[0m{rose_tree(x, s)<_alpha_7>}
{emp}
void rose_tree_free (loc x) {
  if (x == 0) {
  } else {
    rose_tree_free10(x);
  }
}

{_alpha_0x < _alpha_7 && not (x == 0) && s =i {vx} ++ s1x ; (x + 1) :-> bx ** x :-> vx ** buds(bx, s1x)<_alpha_0x>[0,1] ** [x, 2]}
{emp}
void rose_tree_free10 (loc x) {
  let b = *(x + 1);
  if (b == 0) {
    free(x);
  } else {
    let r = *b;
    rose_tree_free(r);
    rose_tree_free10(b);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[rose-tree/copy] should be able to copy a rose tree

[0mGoals generated: 3873[0m
[0mGoals expanded: 3666[0m
[0mAnd-nodes backtracked: 3018[0m
[0mMaximum worklist size: 243[0m
[0mMaximum goal depth: 66[0m
[0mFinal memo size: (2003,47,570)[0m
[0mFinal size of SMT cache: 1093[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 124 times (252ms), failed 2025 times (2997ms)
CheckPost: succeeded 1008 times (1039ms), failed 303 times (76ms)
Read: succeeded 36 times (24ms), failed 2128 times (315ms)
*Partial: succeeded 167 times (68ms), failed 2164 times (223ms)
Inconsistency: succeeded 10 times (24ms), failed 2118 times (250ms)
[0m
[0mSMTSolving          4305ms
CyclicProofChecker  0ms   
                    4305ms[0m
[packed/unpack] 

[0mGoals generated: 2708[0m
[0mGoals expanded: 2249[0m
[0mAnd-nodes backtracked: 1198[0m
[0mMaximum worklist size: 497[0m
[0mMaximum goal depth: 90[0m
[0mFinal memo size: (923,32,969)[0m
[0mFinal size of SMT cache: 539[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 309 times (623ms), failed 850 times (1532ms)
Close: succeeded 342 times (596ms), failed 36 times (1ms)
CheckPost: succeeded 122 times (391ms), failed 277 times (91ms)
Read: succeeded 61 times (49ms), failed 1049 times (299ms)
Inconsistency: succeeded 0 times (0ms), failed 1049 times (343ms)
[0m
[0mSMTSolving          2850ms
CyclicProofChecker  0ms   
                    2850ms[0m
