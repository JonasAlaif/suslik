[ints/swap] should be able to synthesize a swap program

[35m
[ints/swap]:[0m
[0m[0m
[34mvoid swap(x loc, y loc) []
{x :-> a ** y :-> b}
{x :-> b ** y :-> a}
[0m
[32mSuccessfully synthesised in 235 milliseconds:[0m
[0mGoals generated: 12[0m
[0mGoals expanded: 10[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 3[0m
[0mMaximum goal depth: 9[0m
[0mFinal memo size: (0,10,0)[0m
[0mFinal size of SMT cache: 4[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
CheckPost: succeeded 1 times (11ms), failed 3 times (8ms)
Inconsistency: succeeded 0 times (0ms), failed 7 times (17ms)
GhostWrite: succeeded 0 times (0ms), failed 2 times (16ms)
NilNotLval: succeeded 1 times (12ms), failed 7 times (1ms)
Read: succeeded 2 times (8ms), failed 5 times (2ms)
[0m
[0mSMTSolving  202ms
            202ms[0m
[0mvoid swap (loc x, loc y) {
  let a = *x;
  let b = *y;
  *y = a;
  *x = b;
}[0m
[0m-----------------------------------------------------[0m
[sll/len] singly-linked list: length

[35m
[sll/len]:[0m
[0m[0m
[34mvoid sll_len(x loc, ret loc) []
{0 <= n ; ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{ret :-> n ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1285 milliseconds:[0m
[0mGoals generated: 206[0m
[0mGoals expanded: 189[0m
[0mAnd-nodes backtracked: 107[0m
[0mMaximum worklist size: 22[0m
[0mMaximum goal depth: 44[0m
[0mFinal memo size: (87,51,0)[0m
[0mFinal size of SMT cache: 86[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 11 times (60ms), failed 91 times (231ms)
CheckPost: succeeded 32 times (153ms), failed 44 times (46ms)
Inconsistency: succeeded 0 times (0ms), failed 93 times (37ms)
SubstR: succeeded 34 times (20ms), failed 126 times (4ms)
NilNotLval: succeeded 1 times (12ms), failed 93 times (10ms)
[0m
[0mSMTSolving          631ms
CyclicProofChecker  0ms  
                    631ms[0m
[0mvoid sll_len (loc x, loc ret) {
  if (x == 0) {
    *ret = 0;
  } else {
    let n = *(x + 1);
    sll_len(n, ret);
    let l = *ret;
    *ret = l + 1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/min] singly-linked list: min

[35m
[sll/min]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sll_min(x loc, ret loc) []
{ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{s == [] || m == lower s ; ret :-> m ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 5584 milliseconds:[0m
[0mGoals generated: 901[0m
[0mGoals expanded: 814[0m
[0mAnd-nodes backtracked: 339[0m
[0mMaximum worklist size: 43[0m
[0mMaximum goal depth: 97[0m
[0mFinal memo size: (287,322,0)[0m
[0mFinal size of SMT cache: 568[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 53 times (268ms), failed 370 times (1120ms)
AbduceBranch: succeeded 73 times (970ms), failed 65 times (64ms)
Inconsistency: succeeded 15 times (45ms), failed 408 times (325ms)
CheckPost: succeeded 41 times (258ms), failed 124 times (32ms)
SubstR: succeeded 177 times (97ms), failed 550 times (11ms)
[0m
[0mSMTSolving          3002ms
CyclicProofChecker  0ms   
                    3002ms[0m
[0mvoid sll_min (loc x, loc ret) {
  if (x == 0) {
  } else {
    sll_min020010(x, ret);
  }
}

void sll_min020010 (loc x, loc r) {
  let vx = *x;
  let n = *(x + 1);
  sll_min(n, r);
  let m1 = *r;
  if (m1 <= vx && vx <= m1) {
  } else {
    if (n == 0) {
      *r = vx;
    } else {
      let v = *n;
      if (v <= vx && vx <= v) {
        sll_min020010(n, r);
        *x = m1;
      } else {
        if (v <= vx) {
          sll_min020010(n, r);
        } else {
          sll_min020010(n, r);
          let m = *r;
          if (m <= vx) {
            *x = m1;
          } else {
            *r = vx;
          }
        }
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/singleton] singly-linked list: construct a list with one element

[35m
[sll/singleton]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid sll_singleton(x int, ret loc) []
{ret :-> a}
{elems == {x} ; ret :-> y ** sll(y, elems)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 534 milliseconds:[0m
[0mGoals generated: 41[0m
[0mGoals expanded: 31[0m
[0mAnd-nodes backtracked: 8[0m
[0mMaximum worklist size: 11[0m
[0mMaximum goal depth: 21[0m
[0mFinal memo size: (8,22,0)[0m
[0mFinal size of SMT cache: 27[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 1 times (10ms), failed 18 times (77ms)
CheckPost: succeeded 6 times (68ms), failed 7 times (11ms)
Inconsistency: succeeded 0 times (0ms), failed 25 times (19ms)
FrameBlock: succeeded 1 times (2ms), failed 2 times (15ms)
NilNotLval: succeeded 2 times (11ms), failed 25 times (5ms)
[0m
[0mSMTSolving  340ms
            340ms[0m
[0mvoid sll_singleton (int x, loc ret) {
  let y = malloc(2);
  *ret = y;
  *(y + 1) = 0;
  *y = x;
}[0m
[0m-----------------------------------------------------[0m
[sll/init] should be able to initialize a linked list

[35m
[sll/init]:[0m
[0m[0m
[34mvoid sll_init(x loc, v int) []
{sll(x, s)<_alpha_3>}
{s1 <= {v} ; sll(x, s1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 912 milliseconds:[0m
[0mGoals generated: 121[0m
[0mGoals expanded: 112[0m
[0mAnd-nodes backtracked: 70[0m
[0mMaximum worklist size: 11[0m
[0mMaximum goal depth: 29[0m
[0mFinal memo size: (62,35,0)[0m
[0mFinal size of SMT cache: 52[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 2 times (16ms), failed 54 times (177ms)
CheckPost: succeeded 19 times (111ms), failed 17 times (17ms)
SubstR: succeeded 33 times (26ms), failed 62 times (4ms)
Close: succeeded 4 times (26ms), failed 4 times (0ms)
FrameUnfold: succeeded 8 times (8ms), failed 10 times (18ms)
[0m
[0mSMTSolving          478ms
CyclicProofChecker  0ms  
                    478ms[0m
[0mvoid sll_init (loc x, int v) {
  if (x == 0) {
  } else {
    let n = *(x + 1);
    sll_init(n, v);
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/copy] should be able to synthesize list copy

[35m
[sll/copy]:[0m
[0m[0m
[34mvoid sll_copy(r loc) []
{r :-> x ** sll(x, s)<a>}
{r :-> y ** sll(x, s)<a> ** sll(y, s)<b>}
[0m
[32mSuccessfully synthesised in 1401 milliseconds:[0m
[0mGoals generated: 225[0m
[0mGoals expanded: 198[0m
[0mAnd-nodes backtracked: 115[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 53[0m
[0mFinal memo size: (102,63,0)[0m
[0mFinal size of SMT cache: 88[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 13 times (85ms), failed 101 times (293ms)
CheckPost: succeeded 19 times (125ms), failed 27 times (18ms)
Close: succeeded 12 times (39ms), failed 6 times (2ms)
*Partial: succeeded 12 times (13ms), failed 73 times (27ms)
SubstR: succeeded 46 times (26ms), failed 124 times (11ms)
[0m
[0mSMTSolving          666ms
CyclicProofChecker  0ms  
                    666ms[0m
[0mvoid sll_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    sll_copy(r);
    let y1 = *r;
    let y = malloc(2);
    *r = y;
    *(y + 1) = y1;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/multi-append] append multiple lists

[35m
[sll/multi-append]:[0m
[0m[0m
[34mvoid append3(x loc, y loc, z loc, r loc) []
{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
[0m
[32mSuccessfully synthesised in 2213 milliseconds:[0m
[0mGoals generated: 487[0m
[0mGoals expanded: 415[0m
[0mAnd-nodes backtracked: 174[0m
[0mMaximum worklist size: 32[0m
[0mMaximum goal depth: 56[0m
[0mFinal memo size: (158,226,0)[0m
[0mFinal size of SMT cache: 218[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 10 times (31ms), failed 216 times (535ms)
CheckPost: succeeded 62 times (328ms), failed 72 times (48ms)
Inconsistency: succeeded 0 times (0ms), failed 253 times (113ms)
*Partial: succeeded 26 times (14ms), failed 153 times (30ms)
Read: succeeded 17 times (15ms), failed 189 times (25ms)
[0m
[0mSMTSolving          1134ms
CyclicProofChecker  0ms   
                    1134ms[0m
[0m{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
void append3 (loc x, loc y, loc z, loc r) {
  if (x == 0) {
    append300(y, z, r);
  } else {
    let n = *(x + 1);
    append3(n, y, z, r);
    let v = *r;
    *r = x;
    *(x + 1) = v;
  }
}

{not (r == 0) && s1 =i {} && x == 0 ; r :-> a1 ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{not (r == 0) ; r :-> v ** sll(v, s1 ++ s2 ++ s3)<_alpha_6>}
void append300 (loc y, loc z, loc r) {
  if (y == 0) {
    *r = z;
  } else {
    let vy = *y;
    let n = *(y + 1);
    append300(n, z, r);
    let v1 = *r;
    let v = malloc(2);
    free(y);
    *r = v;
    *v = vy;
    *(v + 1) = v1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/union] union of two unique lists

[35m
[sll/union]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid union(r loc, y loc) []
{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 + s2)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 6964 milliseconds:[0m
[0mGoals generated: 1501[0m
[0mGoals expanded: 1455[0m
[0mAnd-nodes backtracked: 1031[0m
[0mMaximum worklist size: 33[0m
[0mMaximum goal depth: 93[0m
[0mFinal memo size: (828,293,0)[0m
[0mFinal size of SMT cache: 844[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 82 times (283ms), failed 682 times (1380ms)
AbduceBranch: succeeded 242 times (1351ms), failed 110 times (60ms)
Inconsistency: succeeded 17 times (39ms), failed 917 times (357ms)
CheckPost: succeeded 41 times (204ms), failed 82 times (51ms)
SubstR: succeeded 253 times (111ms), failed 887 times (13ms)
[0m
[0mSMTSolving          3515ms
CyclicProofChecker  0ms   
                    3515ms[0m
[0m{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 + s2)<_alpha_5>}
void union (loc r, loc y) {
  let x = *r;
  if (x == 0) {
    *r = y;
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    union(r, y);
    union02001302016(v, x, r);
  }
}

{_alpha_1x1 < _alpha_3 && not (r == 0) && not (r == x) && not (vx in s1x1) && not (x == 0) && true ; (x + 1) :-> nxtx11 ** r :-> z1 ** x :-> vx ** ulist(z1, s1x1 ++ s2)<_alpha_51>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> z ** ulist(z, {vx} ++ s1x1 ++ s2)<_alpha_5>}
void union02001302016 (int vx, loc x, loc r) {
  let z1 = *r;
  if (z1 == 0) {
    let z = malloc(2);
    free(x);
    *r = z;
    *z = vx;
    *(z + 1) = 0;
  } else {
    let v = *z1;
    if (vx <= v && v <= vx) {
      let n = *(z1 + 1);
      *r = n;
      union02001302016(v, z1, r);
      free(x);
    } else {
      let n = *(z1 + 1);
      *r = n;
      *z1 = vx;
      union02001302016(vx, z1, r);
      let z2 = *r;
      let z = malloc(2);
      free(x);
      *r = z;
      *z = v;
      *(z + 1) = z2;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/intersect] intersect two unique lists

[0mGoals generated: 2894[0m
[0mGoals expanded: 2754[0m
[0mAnd-nodes backtracked: 1604[0m
[0mMaximum worklist size: 120[0m
[0mMaximum goal depth: 99[0m
[0mFinal memo size: (1446,147,401)[0m
[0mFinal size of SMT cache: 828[0m
[0mTime spent cycling: 4ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 137 times (466ms), failed 1275 times (1560ms)
AbduceBranch: succeeded 122 times (658ms), failed 45 times (34ms)
CheckPost: succeeded 207 times (349ms), failed 463 times (104ms)
SubstR: succeeded 852 times (370ms), failed 1695 times (16ms)
Inconsistency: succeeded 6 times (17ms), failed 1258 times (213ms)
[0m
[0mSMTSolving          3171ms
CyclicProofChecker  2ms   
                    3173ms[0m
[sll/diff] difference of two unique lists

[35m
[sll/diff]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid diff(r loc, y loc) []
{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 - s2)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 7992 milliseconds:[0m
[0mGoals generated: 1939[0m
[0mGoals expanded: 1919[0m
[0mAnd-nodes backtracked: 1666[0m
[0mMaximum worklist size: 28[0m
[0mMaximum goal depth: 92[0m
[0mFinal memo size: (1342,210,0)[0m
[0mFinal size of SMT cache: 961[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 109 times (262ms), failed 919 times (1693ms)
AbduceBranch: succeeded 371 times (1500ms), failed 171 times (112ms)
Inconsistency: succeeded 14 times (40ms), failed 1205 times (313ms)
CheckPost: succeeded 36 times (191ms), failed 76 times (57ms)
Read: succeeded 19 times (17ms), failed 905 times (145ms)
[0m
[0mSMTSolving          3864ms
CyclicProofChecker  0ms   
                    3864ms[0m
[0m{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 - s2)<_alpha_5>}
void diff (loc r, loc y) {
  if (y == 0) {
  } else {
    let v = *y;
    let n = *(y + 1);
    diff(r, n);
    diff02001302016(v, r, y);
  }
}

{_alpha_1y < _alpha_4 && not (r == 0) && not (r == y) && not (vy in s1y) && not (y == 0) && true ; (y + 1) :-> nxty1 ** r :-> z1 ** y :-> vy ** ulist(z1, s1 -- s1y)<_alpha_51>[1,0] ** [y, 2]}
{not (r == 0) ; r :-> z ** ulist(z, s1 -- ({vy} ++ s1y))<_alpha_5>}
void diff02001302016 (int vy, loc r, loc y) {
  let z1 = *r;
  if (z1 == 0) {
    free(y);
  } else {
    let v = *z1;
    if (vy <= v && v <= vy) {
      let n = *(z1 + 1);
      *r = n;
      diff02001302016(v, r, z1);
      free(y);
    } else {
      let n = *(z1 + 1);
      *r = n;
      *z1 = vy;
      diff02001302016(vy, r, z1);
      let z2 = *r;
      let z = malloc(2);
      free(y);
      *r = z;
      *z = v;
      *(z + 1) = z2;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/insertion-sort] sorted list: insert an element

[35m
[srtl/insertion-sort]:[0m
[0m[0m
[34mvoid insertion_sort(x loc, r loc) []
{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_5>}
{r :-> y ** sll(x, s, n)<_alpha_6> ** srtl(y, s, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 1804 milliseconds:[0m
[0mGoals generated: 405[0m
[0mGoals expanded: 377[0m
[0mAnd-nodes backtracked: 250[0m
[0mMaximum worklist size: 26[0m
[0mMaximum goal depth: 59[0m
[0mFinal memo size: (223,68,0)[0m
[0mFinal size of SMT cache: 86[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 28 times (111ms), failed 170 times (360ms)
CheckPost: succeeded 32 times (92ms), failed 75 times (33ms)
SubstR: succeeded 108 times (60ms), failed 244 times (7ms)
Close: succeeded 19 times (65ms), failed 7 times (0ms)
*Partial: succeeded 16 times (14ms), failed 65 times (26ms)
[0m
[0mSMTSolving          757ms
CyclicProofChecker  0ms  
                    757ms[0m
[0mvoid insertion_sort (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    insertion_sort(n, r);
    let y = *r;
    *r = v;
    srtl_insert(y, r);
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/sort] sort a list

[35m
[srtl/sort]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sort(x loc) []
{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1862 milliseconds:[0m
[0mGoals generated: 270[0m
[0mGoals expanded: 254[0m
[0mAnd-nodes backtracked: 110[0m
[0mMaximum worklist size: 14[0m
[0mMaximum goal depth: 67[0m
[0mFinal memo size: (99,139,0)[0m
[0mFinal size of SMT cache: 130[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 20 times (97ms), failed 104 times (345ms)
AbduceBranch: succeeded 14 times (166ms), failed 18 times (17ms)
Inconsistency: succeeded 6 times (23ms), failed 162 times (100ms)
CheckPost: succeeded 9 times (82ms), failed 23 times (21ms)
SubstR: succeeded 75 times (57ms), failed 149 times (9ms)
[0m
[0mSMTSolving          935ms
CyclicProofChecker  0ms  
                    935ms[0m
[0m{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
void sort (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    sort(n);
    sort00140209(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_0x < _alpha_3 && not (x == 0) && true ; (x + 1) :-> nx ** x :-> vx ** srtl(nx, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{srtl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void sort00140209 (loc nx, int vx, loc x) {
  if (nx == 0) {
  } else {
    let v = *nx;
    if (vx <= v) {
      let n = *(nx + 1);
      sort00140209(n, v, nx);
    } else {
      let n = *(nx + 1);
      *nx = vx;
      sort00140209(n, vx, nx);
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/merge] sorted list: merge

[0mGoals generated: 1642[0m
[0mGoals expanded: 1594[0m
[0mAnd-nodes backtracked: 1141[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 93[0m
[0mFinal memo size: (896,216,237)[0m
[0mFinal size of SMT cache: 788[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 362 times (2506ms), failed 123 times (149ms)
PostInconsistent: succeeded 64 times (338ms), failed 718 times (2122ms)
Inconsistency: succeeded 9 times (33ms), failed 1053 times (604ms)
Read: succeeded 22 times (23ms), failed 725 times (185ms)
SubstR: succeeded 320 times (177ms), failed 856 times (11ms)
[0m
[0mSMTSolving          5452ms
CyclicProofChecker  0ms   
                    5452ms[0m
[dll/singleton] singly-linked list: construct a list with one element

[35m
[dll/singleton]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid dll_singleton(x int, ret loc) []
{ret :-> a}
{elems == {x} ; ret :-> y ** dll(y, 0, elems)<_alpha_2>}
[0m
[32mSuccessfully synthesised in 585 milliseconds:[0m
[0mGoals generated: 47[0m
[0mGoals expanded: 35[0m
[0mAnd-nodes backtracked: 11[0m
[0mMaximum worklist size: 13[0m
[0mMaximum goal depth: 22[0m
[0mFinal memo size: (11,23,0)[0m
[0mFinal size of SMT cache: 29[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 1 times (9ms), failed 21 times (94ms)
CheckPost: succeeded 6 times (64ms), failed 8 times (12ms)
Inconsistency: succeeded 0 times (0ms), failed 29 times (19ms)
FrameBlock: succeeded 1 times (2ms), failed 2 times (16ms)
Read: succeeded 1 times (6ms), failed 22 times (12ms)
[0m
[0mSMTSolving  335ms
            335ms[0m
[0mvoid dll_singleton (int x, loc ret) {
  let y = malloc(3);
  *ret = y;
  *(y + 1) = 0;
  *(y + 2) = 0;
  *y = x;
}[0m
[0m-----------------------------------------------------[0m
[dll/copy] should be able to synthesize list copy

[0mGoals generated: 5083[0m
[0mGoals expanded: 5038[0m
[0mAnd-nodes backtracked: 4836[0m
[0mMaximum worklist size: 81[0m
[0mMaximum goal depth: 68[0m
[0mFinal memo size: (3453,83,109)[0m
[0mFinal size of SMT cache: 662[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 200 times (403ms), failed 2152 times (1812ms)
CheckPost: succeeded 992 times (659ms), failed 376 times (44ms)
Read: succeeded 15 times (10ms), failed 2346 times (391ms)
SubstR: succeeded 1109 times (281ms), failed 2369 times (38ms)
*Partial: succeeded 193 times (67ms), failed 1953 times (184ms)
[0m
[0mSMTSolving          2815ms
CyclicProofChecker  0ms   
                    2815ms[0m
[dll/append] doubly-linked list: append

[0mGoals generated: 2595[0m
[0mGoals expanded: 2515[0m
[0mAnd-nodes backtracked: 1398[0m
[0mMaximum worklist size: 185[0m
[0mMaximum goal depth: 72[0m
[0mFinal memo size: (1273,156,807)[0m
[0mFinal size of SMT cache: 585[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 74 times (185ms), failed 1154 times (1476ms)
CheckPost: succeeded 275 times (566ms), failed 428 times (62ms)
Inconsistency: succeeded 12 times (36ms), failed 1261 times (342ms)
SubstR: succeeded 601 times (206ms), failed 1623 times (11ms)
Read: succeeded 81 times (46ms), failed 753 times (143ms)
[0m
[0mSMTSolving          2630ms
CyclicProofChecker  0ms   
                    2630ms[0m
[dll/delete-all] doubly-linked list: delete all occurrences of x

[35m
[dll/delete-all]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid dll_delete_all(x loc, ret loc) []
{ret :-> a ** dll(x, b, s)<_alpha_2>}
{s1 == s - {a} ; ret :-> y ** dll(y, c, s1)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 8060 milliseconds:[0m
[0mGoals generated: 3028[0m
[0mGoals expanded: 2994[0m
[0mAnd-nodes backtracked: 2760[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (1660,213,0)[0m
[0mFinal size of SMT cache: 593[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 655 times (1554ms), failed 312 times (66ms)
PostInconsistent: succeeded 317 times (227ms), failed 1129 times (946ms)
Inconsistency: succeeded 17 times (38ms), failed 1726 times (300ms)
Read: succeeded 18 times (18ms), failed 1428 times (228ms)
Pick: succeeded 273 times (222ms), failed 25 times (3ms)
[0m
[0mSMTSolving          2783ms
CyclicProofChecker  0ms   
                    2783ms[0m
[0mvoid dll_delete_all (loc x, loc ret) {
  let a = *ret;
  if (x == 0) {
    *ret = 0;
  } else {
    let vx = *x;
    if (a <= vx && vx <= a) {
      let w = *(x + 1);
      dll_delete_all(w, ret);
      free(x);
    } else {
      let w = *(x + 1);
      let b = *(x + 2);
      dll_delete_all(w, ret);
      let y1 = *ret;
      if (y1 == 0) {
        let y = malloc(3);
        free(x);
        *ret = y;
        *y = vx;
        *(y + 1) = 0;
        *(y + 2) = b;
      } else {
        let v = *y1;
        if (vx <= v && v <= vx) {
          free(x);
          *(y1 + 2) = b;
        } else {
          let y = malloc(3);
          free(x);
          *(y1 + 2) = y;
          *y1 = vx;
          *ret = y;
          *y = v;
          *(y + 1) = y1;
          *(y + 2) = b;
        }
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[multi-list/len] should be able to compute a length of a multi-list

[35m
[multi-list/len]:[0m
[0mmaxOpenDepth = 2, maxCloseDepth = 2[0m
[34mvoid multilist_length(r loc) []
{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> len ** multilist(x, len, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 6079 milliseconds:[0m
[0mGoals generated: 1774[0m
[0mGoals expanded: 1709[0m
[0mAnd-nodes backtracked: 1188[0m
[0mMaximum worklist size: 55[0m
[0mMaximum goal depth: 104[0m
[0mFinal memo size: (1076,171,0)[0m
[0mFinal size of SMT cache: 427[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 59 times (165ms), failed 700 times (1386ms)
CheckPost: succeeded 135 times (397ms), failed 241 times (177ms)
SubstR: succeeded 699 times (274ms), failed 877 times (14ms)
PureSynthesisFinal: succeeded 7 times (273ms), failed 19 times (0ms)
Close: succeeded 114 times (163ms), failed 63 times (1ms)
[0m
[0mSMTSolving          2219ms
CyclicProofChecker  0ms   
                    2219ms[0m
[0m{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> len ** multilist(x, len, s)<_alpha_4>}
void multilist_length (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let h = *x;
    let t = *(x + 1);
    if (h == 0) {
      *r = t;
      multilist_length(r);
    } else {
      multilist_length1710(t, h, x, r);
    }
  }
}

{_alpha_0hx11 < _alpha_1x1 && _alpha_1x1 < _alpha_3 && _alpha_2x1 < _alpha_3 && len1x1 == 1 + len1hx11 && not (hx == 0) && not (r == 0) && not (r == x) && not (x == 0) && s1x1 =i {vhx11} ++ s1hx11 ; (hx + 1) :-> nxthx11 ** (x + 1) :-> tx ** hx :-> vhx11 ** r :-> x ** x :-> hx ** multilist(tx, size2x1, s2x1)<_alpha_2x1>[0,1] ** sll(nxthx11, len1hx11, s1hx11)<_alpha_0hx11>[0,2] ** [hx, 2] ** [x, 2]}
{not (r == 0) ; r :-> len1x1 + size2x1 ** multilist(x, len1x1 + size2x1, s1x1 ++ s2x1)<_alpha_4>}
void multilist_length1710 (loc tx, loc hx, loc x, loc r) {
  let v = *hx;
  let n = *(hx + 1);
  *(hx + 1) = tx;
  *hx = n;
  *r = hx;
  multilist_length10(hx, r);
  let h = *hx;
  let t = *(hx + 1);
  *(hx + 1) = h;
  *r = x;
  *(x + 1) = t;
  *hx = v;
  multilist_length1710(t, hx, x, r);
}[0m
[0m-----------------------------------------------------[0m
[tree/copy] should be able to synthesize a tree copy (with elements)

[35m
[tree/copy]:[0m
[0m[0m
[34mvoid tree_copy(r loc) []
{r :-> x ** tree(x, s)<_alpha_10>}
{r :-> y ** tree(x, s)<_alpha_11> ** tree(y, s)<_alpha_12>}
[0m
[32mSuccessfully synthesised in 3777 milliseconds:[0m
[0mGoals generated: 1228[0m
[0mGoals expanded: 1145[0m
[0mAnd-nodes backtracked: 847[0m
[0mMaximum worklist size: 80[0m
[0mMaximum goal depth: 81[0m
[0mFinal memo size: (739,91,0)[0m
[0mFinal size of SMT cache: 230[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 32 times (106ms), failed 548 times (941ms)
CheckPost: succeeded 127 times (293ms), failed 170 times (25ms)
SubstR: succeeded 365 times (133ms), failed 656 times (19ms)
Read: succeeded 12 times (10ms), failed 419 times (90ms)
FrameUnfold: succeeded 107 times (56ms), failed 89 times (21ms)
[0m
[0mSMTSolving          1435ms
CyclicProofChecker  1ms   
                    1436ms[0m
[0mvoid tree_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let rx = *(x + 2);
    *r = l;
    tree_copy(r);
    let y1 = *r;
    *r = rx;
    tree_copy(r);
    let y2 = *r;
    let y = malloc(3);
    *r = y;
    *(y + 1) = y1;
    *(y + 2) = y2;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-acc] should be able to flatten the tree into a list given a list accumulator

[35m
[tree/flatten-acc]:[0m
[0m[0m
[34mvoid tree_flatten(x loc, z loc) []
{z :-> y ** sll(y, acc)<_alpha_11> ** tree(x, s)<_alpha_10>}
{s1 == s + acc ; z :-> t ** sll(t, s1)<_alpha_12>}
[0m
[32mSuccessfully synthesised in 1302 milliseconds:[0m
[0mGoals generated: 196[0m
[0mGoals expanded: 172[0m
[0mAnd-nodes backtracked: 49[0m
[0mMaximum worklist size: 15[0m
[0mMaximum goal depth: 71[0m
[0mFinal memo size: (47,123,0)[0m
[0mFinal size of SMT cache: 76[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 5 times (17ms), failed 86 times (241ms)
CheckPost: succeeded 21 times (169ms), failed 35 times (29ms)
Inconsistency: succeeded 0 times (0ms), failed 98 times (54ms)
SubstR: succeeded 41 times (28ms), failed 107 times (4ms)
Close: succeeded 8 times (26ms), failed 6 times (2ms)
[0m
[0mSMTSolving          647ms
CyclicProofChecker  0ms  
                    647ms[0m
[0mvoid tree_flatten (loc x, loc z) {
  let y = *z;
  if (y == 0) {
    tree_flatten00(x, z);
  } else {
    let n = *(y + 1);
    *z = n;
    tree_flatten(x, z);
    let t = *z;
    *z = y;
    *(y + 1) = t;
  }
}

void tree_flatten00 (loc x, loc z) {
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    tree_flatten00(l, z);
    tree_flatten(r, z);
    let t2 = *z;
    let t = malloc(2);
    free(x);
    *z = t;
    *t = v;
    *(t + 1) = t2;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten] should be able to flatten the tree into a list

[35m
[tree/flatten]:[0m
[0m[0m
[34mvoid flatten(z loc) []
{z :-> x ** tree(x, s)<_alpha_10>}
{z :-> y ** sll(y, s)<_alpha_11>}
[0m
[32mSuccessfully synthesised in 1597 milliseconds:[0m
[0mGoals generated: 271[0m
[0mGoals expanded: 243[0m
[0mAnd-nodes backtracked: 75[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 81[0m
[0mFinal memo size: (73,124,0)[0m
[0mFinal size of SMT cache: 102[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 9 times (31ms), failed 126 times (302ms)
CheckPost: succeeded 27 times (195ms), failed 59 times (55ms)
Inconsistency: succeeded 0 times (0ms), failed 114 times (58ms)
SubstR: succeeded 55 times (37ms), failed 166 times (5ms)
Read: succeeded 12 times (18ms), failed 81 times (11ms)
[0m
[0mSMTSolving          742ms
CyclicProofChecker  0ms  
                    742ms[0m
[0m{z :-> x ** tree(x, s)<_alpha_10>}
{z :-> y ** sll(y, s)<_alpha_11>}
void flatten (loc z) {
  let x = *z;
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    *z = l;
    flatten(z);
    flatten118(r, v, x, z);
  }
}

{_alpha_1x1 < _alpha_10 && _alpha_2x1 < _alpha_10 && not (x == 0) && not (x == z) && not (z == 0) ; (x + 1) :-> lx11 ** (x + 2) :-> r ** x :-> v ** z :-> y1 ** sll(y1, s1x1)<_alpha_111>[1,0] ** tree(r, s2x1)<_alpha_2x1>[0,1] ** [x, 3]}
{not (z == 0) ; z :-> y ** sll(y, {v} ++ s1x1 ++ s2x1)<_alpha_11>}
void flatten118 (loc r, int v, loc x, loc z) {
  let y1 = *z;
  if (y1 == 0) {
    *z = r;
    flatten(z);
    let y2 = *z;
    let y = malloc(2);
    free(x);
    *z = y;
    *y = v;
    *(y + 1) = y2;
  } else {
    let n = *(y1 + 1);
    *z = n;
    flatten118(r, v, x, z);
    let y = *z;
    *z = y1;
    *(y1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-dll] flatten the tree into a doubly-linked list in place

[0mGoals generated: 3196[0m
[0mGoals expanded: 3181[0m
[0mAnd-nodes backtracked: 2394[0m
[0mMaximum worklist size: 66[0m
[0mMaximum goal depth: 78[0m
[0mFinal memo size: (2124,84,681)[0m
[0mFinal size of SMT cache: 708[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 167 times (410ms), failed 1300 times (1462ms)
CheckPost: succeeded 360 times (856ms), failed 228 times (117ms)
Inconsistency: succeeded 36 times (76ms), failed 2170 times (324ms)
SubstR: succeeded 892 times (307ms), failed 1728 times (23ms)
Read: succeeded 129 times (61ms), failed 1225 times (148ms)
[0m
[0mSMTSolving          3139ms
CyclicProofChecker  0ms   
                    3139ms[0m
[tree/flatten-dll-linear] flatten a tree into a doubly-linked list in learn time

[0mGoals generated: 2972[0m
[0mGoals expanded: 2868[0m
[0mAnd-nodes backtracked: 2157[0m
[0mMaximum worklist size: 84[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (1764,399,300)[0m
[0mFinal size of SMT cache: 921[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 189 times (547ms), failed 1136 times (1753ms)
CheckPost: succeeded 384 times (741ms), failed 352 times (737ms)
Inconsistency: succeeded 16 times (38ms), failed 1670 times (248ms)
SubstR: succeeded 755 times (266ms), failed 1441 times (18ms)
Read: succeeded 68 times (31ms), failed 1102 times (149ms)
[0m
[0mSMTSolving          3894ms
CyclicProofChecker  0ms   
                    3894ms[0m
[bst/insert] binary search tree: insert an element

[0mGoals generated: 2749[0m
[0mGoals expanded: 2381[0m
[0mAnd-nodes backtracked: 880[0m
[0mMaximum worklist size: 365[0m
[0mMaximum goal depth: 82[0m
[0mFinal memo size: (850,28,1471)[0m
[0mFinal size of SMT cache: 195[0m
[0mTime spent cycling: 8ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 42 times (60ms), failed 1345 times (605ms)
CheckPost: succeeded 318 times (262ms), failed 894 times (50ms)
AbduceBranch: succeeded 42 times (266ms), failed 19 times (13ms)
SubstR: succeeded 535 times (259ms), failed 2182 times (8ms)
HeapUnifyPure: succeeded 334 times (180ms), failed 317 times (5ms)
[0m
[0mSMTSolving          1265ms
CyclicProofChecker  3ms   
                    1268ms[0m
[bst/right-rotate] binary search tree: rotate right

[35m
[bst/right-rotate]:[0m
[0m[0m
[34mvoid bst_right_rotate(x loc, ret loc) []
{0 <= sz1 && 0 <= sz2 && not (l == 0) && upper s1 <= v && v == lower ([v] + s2) ; (x + 1) :-> l ** (x + 2) :-> r ** ret :-> unused ** x :-> v ** bst(l, s1, sz1)<_alpha_4> ** bst(r, s2, sz2)<_alpha_5> ** [x, 3]}
{sz3 + sz4 == sz1 + sz2 && v3 <= lower s4 && v3 == upper ([v3] + s3) ; (y + 1) :-> l3 ** (y + 2) :-> x ** ret :-> y ** y :-> v3 ** bst(l3, s3, sz3)<_alpha_6> ** bst(x, s4, sz4)<_alpha_7> ** [y, 3]}
[0m
[32mSuccessfully synthesised in 7215 milliseconds:[0m
[0mGoals generated: 1623[0m
[0mGoals expanded: 1577[0m
[0mAnd-nodes backtracked: 1483[0m
[0mMaximum worklist size: 49[0m
[0mMaximum goal depth: 63[0m
[0mFinal memo size: (1129,69,0)[0m
[0mFinal size of SMT cache: 480[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 32 times (166ms), failed 730 times (2040ms)
CheckPost: succeeded 361 times (1322ms), failed 78 times (124ms)
Read: succeeded 10 times (24ms), failed 751 times (313ms)
Inconsistency: succeeded 2 times (7ms), failed 1054 times (201ms)
SubstR: succeeded 324 times (165ms), failed 772 times (25ms)
[0m
[0mSMTSolving  3706ms
            3706ms[0m
[0mvoid bst_right_rotate (loc x, loc ret) {
  let l = *(x + 1);
  let r = *(l + 2);
  *(l + 2) = x;
  *(x + 1) = r;
  *ret = l;
}[0m
[0m-----------------------------------------------------[0m
[bst/min] binary search tree: find smallest element

[0mGoals generated: 1718[0m
[0mGoals expanded: 1639[0m
[0mAnd-nodes backtracked: 1044[0m
[0mMaximum worklist size: 160[0m
[0mMaximum goal depth: 79[0m
[0mFinal memo size: (913,8,512)[0m
[0mFinal size of SMT cache: 488[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 18 times (101ms), failed 832 times (1869ms)
CheckPost: succeeded 290 times (999ms), failed 443 times (138ms)
Inconsistency: succeeded 0 times (0ms), failed 538 times (208ms)
SubstR: succeeded 377 times (169ms), failed 1204 times (19ms)
Close: succeeded 39 times (90ms), failed 11 times (0ms)
[0m
[0mSMTSolving          3240ms
CyclicProofChecker  2ms   
                    3242ms[0m
[bst/max] binary search tree: find smallest element

[0mGoals generated: 1718[0m
[0mGoals expanded: 1639[0m
[0mAnd-nodes backtracked: 1044[0m
[0mMaximum worklist size: 160[0m
[0mMaximum goal depth: 79[0m
[0mFinal memo size: (913,8,512)[0m
[0mFinal size of SMT cache: 488[0m
[0mTime spent cycling: 4ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 18 times (111ms), failed 832 times (1878ms)
CheckPost: succeeded 290 times (1032ms), failed 443 times (137ms)
Inconsistency: succeeded 0 times (0ms), failed 538 times (245ms)
SubstR: succeeded 377 times (150ms), failed 1204 times (7ms)
Close: succeeded 39 times (106ms), failed 11 times (0ms)
[0m
[0mSMTSolving          3303ms
CyclicProofChecker  0ms   
                    3303ms[0m
[bst/delete-root] binary search tree: delete root

[0mGoals generated: 1890[0m
[0mGoals expanded: 1856[0m
[0mAnd-nodes backtracked: 1609[0m
[0mMaximum worklist size: 56[0m
[0mMaximum goal depth: 103[0m
[0mFinal memo size: (1297,10,230)[0m
[0mFinal size of SMT cache: 495[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 22 times (112ms), failed 845 times (3400ms)
CheckPost: succeeded 412 times (1894ms), failed 229 times (102ms)
SubstR: succeeded 534 times (274ms), failed 938 times (14ms)
Read: succeeded 11 times (18ms), failed 650 times (139ms)
*Partial: succeeded 45 times (42ms), failed 583 times (79ms)
[0m
[0mSMTSolving          5429ms
CyclicProofChecker  0ms   
                    5429ms[0m
[rose-tree/copy] should be able to copy a rose tree

[0mGoals generated: 3066[0m
[0mGoals expanded: 2757[0m
[0mAnd-nodes backtracked: 1495[0m
[0mMaximum worklist size: 323[0m
[0mMaximum goal depth: 98[0m
[0mFinal memo size: (1246,40,1186)[0m
[0mFinal size of SMT cache: 432[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 168 times (269ms), failed 1220 times (1212ms)
CheckPost: succeeded 223 times (487ms), failed 522 times (142ms)
SubstR: succeeded 879 times (342ms), failed 1641 times (14ms)
Close: succeeded 222 times (270ms), failed 67 times (0ms)
*Partial: succeeded 142 times (60ms), failed 499 times (54ms)
[0m
[0mSMTSolving          2124ms
CyclicProofChecker  1ms   
                    2125ms[0m
[packed/unpack] 

[0mGoals generated: 2263[0m
[0mGoals expanded: 2038[0m
[0mAnd-nodes backtracked: 1042[0m
[0mMaximum worklist size: 304[0m
[0mMaximum goal depth: 95[0m
[0mFinal memo size: (968,32,873)[0m
[0mFinal size of SMT cache: 438[0m
[0mTime spent cycling: 4ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 120 times (328ms), failed 1017 times (1115ms)
CheckPost: succeeded 231 times (550ms), failed 610 times (167ms)
SubstR: succeeded 410 times (200ms), failed 1654 times (27ms)
Close: succeeded 99 times (171ms), failed 24 times (1ms)
HeapUnifyPure: succeeded 245 times (114ms), failed 162 times (0ms)
[0m
[0mSMTSolving          2159ms
CyclicProofChecker  1ms   
                    2160ms[0m
