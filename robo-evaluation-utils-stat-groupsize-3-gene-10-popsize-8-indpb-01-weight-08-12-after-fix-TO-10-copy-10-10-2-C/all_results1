[sll/max] singly-linked list: max

[35m
[sll/max]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sll_max(x loc, ret loc) []
{ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{s == [] || m == upper s ; ret :-> m ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 4865 milliseconds:[0m
[0mGoals generated: 704[0m
[0mGoals expanded: 654[0m
[0mAnd-nodes backtracked: 335[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 76[0m
[0mFinal memo size: (275,271,0)[0m
[0mFinal size of SMT cache: 546[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 78 times (1238ms), failed 81 times (117ms)
PostInconsistent: succeeded 51 times (250ms), failed 275 times (1082ms)
Inconsistency: succeeded 10 times (32ms), failed 472 times (241ms)
Read: succeeded 9 times (11ms), failed 449 times (105ms)
SubstR: succeeded 163 times (86ms), failed 351 times (7ms)
[0m
[0mSMTSolving          2914ms
CyclicProofChecker  0ms   
                    2914ms[0m
[0mvoid sll_max (loc x, loc ret) {
  if (x == 0) {
  } else {
    let vx = *x;
    let nxt = *(x + 1);
    sll_max(nxt, ret);
    let m = *ret;
    if (m <= vx && vx <= m) {
      *x = m;
    } else {
      if (vx <= m) {
        if (nxt == 0) {
          *ret = vx;
          *(x + 1) = 0;
        } else {
          let v = *nxt;
          let nx = *(nxt + 1);
          if (vx <= v && v <= vx) {
            let n = malloc(2);
            free(nxt);
            *(x + 1) = n;
            *x = v;
            *n = m;
            *(n + 1) = nx;
          } else {
            if (vx <= v) {
              let n = malloc(2);
              free(nxt);
              *(x + 1) = n;
              *n = m;
              *(n + 1) = nx;
            } else {
              let n = malloc(2);
              free(nxt);
              *(x + 1) = n;
              *x = v;
              *n = m;
              *(n + 1) = nx;
            }
          }
        }
      } else {
        *ret = vx;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/free] should be able to deallocate a linked list

[35m
[sll/free]:[0m
[0m[0m
[34mvoid sll_free(x loc) []
{sll(x, s)<_alpha_3>}
{emp}
[0m
[32mSuccessfully synthesised in 320 milliseconds:[0m
[0mGoals generated: 16[0m
[0mGoals expanded: 17[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 1[0m
[0mMaximum goal depth: 14[0m
[0mFinal memo size: (0,17,0)[0m
[0mFinal size of SMT cache: 8[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 0 times (0ms), failed 11 times (27ms)
Open: succeeded 1 times (19ms), failed 1 times (0ms)
FrameUnfold: succeeded 1 times (1ms), failed 3 times (18ms)
Inconsistency: succeeded 0 times (0ms), failed 7 times (18ms)
CheckPost: succeeded 0 times (0ms), failed 5 times (12ms)
[0m
[0mSMTSolving          208ms
CyclicProofChecker  0ms  
                    208ms[0m
[0mvoid sll_free (loc x) {
  if (x == 0) {
  } else {
    let n = *(x + 1);
    sll_free(n);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/copy] should be able to synthesize list copy

[35m
[sll/copy]:[0m
[0m[0m
[34mvoid sll_copy(r loc) []
{r :-> x ** sll(x, s)<a>}
{r :-> y ** sll(x, s)<a> ** sll(y, s)<b>}
[0m
[32mSuccessfully synthesised in 1304 milliseconds:[0m
[0mGoals generated: 208[0m
[0mGoals expanded: 182[0m
[0mAnd-nodes backtracked: 116[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 53[0m
[0mFinal memo size: (101,63,0)[0m
[0mFinal size of SMT cache: 79[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 12 times (77ms), failed 83 times (253ms)
CheckPost: succeeded 18 times (134ms), failed 18 times (15ms)
*Partial: succeeded 14 times (14ms), failed 123 times (29ms)
Close: succeeded 13 times (38ms), failed 6 times (0ms)
Read: succeeded 4 times (8ms), failed 119 times (26ms)
[0m
[0mSMTSolving          637ms
CyclicProofChecker  0ms  
                    637ms[0m
[0mvoid sll_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    sll_copy(r);
    let y1 = *r;
    let y = malloc(2);
    *r = y;
    *(y + 1) = y1;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/free2] Deallocate two linked lists (needs listfree as an auxiliary, unless we can pass emp as a list)

[35m
[sll/free2]:[0m
[0m[0m
[34mvoid listfree2(x loc, y loc) []
{sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4>}
{emp}
[0m
[32mSuccessfully synthesised in 677 milliseconds:[0m
[0mGoals generated: 66[0m
[0mGoals expanded: 66[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 5[0m
[0mMaximum goal depth: 19[0m
[0mFinal memo size: (0,59,0)[0m
[0mFinal size of SMT cache: 28[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 0 times (0ms), failed 41 times (137ms)
Inconsistency: succeeded 0 times (0ms), failed 22 times (51ms)
Open: succeeded 5 times (33ms), failed 2 times (0ms)
CheckPost: succeeded 0 times (0ms), failed 15 times (23ms)
FrameUnfold: succeeded 4 times (5ms), failed 11 times (17ms)
[0m
[0mSMTSolving          374ms
CyclicProofChecker  0ms  
                    374ms[0m
[0mvoid listfree2 (loc x, loc y) {
  if (x == 0) {
    listfree200(y);
  } else {
    let n = *(x + 1);
    listfree2(n, y);
    free(x);
  }
}

void listfree200 (loc y) {
  if (y == 0) {
  } else {
    let n = *(y + 1);
    listfree200(n);
    free(y);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/union] union of two unique lists

[0mGoals generated: 2682[0m
[0mGoals expanded: 2612[0m
[0mAnd-nodes backtracked: 2189[0m
[0mMaximum worklist size: 28[0m
[0mMaximum goal depth: 74[0m
[0mFinal memo size: (1627,248,175)[0m
[0mFinal size of SMT cache: 1179[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 582 times (2305ms), failed 267 times (150ms)
PostInconsistent: succeeded 204 times (490ms), failed 1158 times (1545ms)
Inconsistency: succeeded 10 times (29ms), failed 1760 times (470ms)
Read: succeeded 21 times (15ms), failed 1656 times (313ms)
*Partial: succeeded 83 times (40ms), failed 1677 times (128ms)
[0m
[0mSMTSolving          4563ms
CyclicProofChecker  0ms   
                    4563ms[0m
[sll/intersect] intersect two unique lists

[0mGoals generated: 3299[0m
[0mGoals expanded: 3191[0m
[0mAnd-nodes backtracked: 2714[0m
[0mMaximum worklist size: 73[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (2299,115,353)[0m
[0mFinal size of SMT cache: 1073[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 186 times (642ms), failed 1358 times (2123ms)
AbduceBranch: succeeded 327 times (1065ms), failed 107 times (47ms)
Read: succeeded 32 times (19ms), failed 2125 times (296ms)
SubstR: succeeded 840 times (269ms), failed 1547 times (31ms)
Inconsistency: succeeded 3 times (9ms), failed 2312 times (269ms)
[0m
[0mSMTSolving          4028ms
CyclicProofChecker  0ms   
                    4028ms[0m
[sll/diff] difference of two unique lists

[0mGoals generated: 2515[0m
[0mGoals expanded: 2470[0m
[0mAnd-nodes backtracked: 2160[0m
[0mMaximum worklist size: 20[0m
[0mMaximum goal depth: 97[0m
[0mFinal memo size: (1730,168,141)[0m
[0mFinal size of SMT cache: 1205[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 188 times (463ms), failed 1109 times (1987ms)
AbduceBranch: succeeded 456 times (2084ms), failed 218 times (147ms)
Inconsistency: succeeded 6 times (20ms), failed 1609 times (448ms)
Read: succeeded 24 times (15ms), failed 1488 times (237ms)
CheckPost: succeeded 36 times (190ms), failed 76 times (53ms)
[0m
[0mSMTSolving          5008ms
CyclicProofChecker  0ms   
                    5008ms[0m
[srtl/insert] sorted list: insert an element

[35m
[srtl/insert]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid srtl_insert(x loc, r loc) [k int]
{0 <= l ; r :-> k ** srtl(x, s, l)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], l + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 4137 milliseconds:[0m
[0mGoals generated: 657[0m
[0mGoals expanded: 639[0m
[0mAnd-nodes backtracked: 478[0m
[0mMaximum worklist size: 13[0m
[0mMaximum goal depth: 57[0m
[0mFinal memo size: (367,160,0)[0m
[0mFinal size of SMT cache: 445[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 148 times (1254ms), failed 64 times (70ms)
PostInconsistent: succeeded 28 times (163ms), failed 275 times (816ms)
Inconsistency: succeeded 7 times (18ms), failed 443 times (203ms)
*Partial: succeeded 28 times (19ms), failed 415 times (86ms)
Read: succeeded 4 times (8ms), failed 411 times (87ms)
[0m
[0mSMTSolving          2496ms
CyclicProofChecker  0ms   
                    2496ms[0m
[0mvoid srtl_insert (loc x, loc r) {
  let k = *r;
  if (x == 0) {
    let y = malloc(2);
    *r = y;
    *y = lower ([] ++ [k]);
    *(y + 1) = 0;
  } else {
    let v = *x;
    let nx = *(x + 1);
    if (k <= v && v <= k) {
      let n = malloc(2);
      *(x + 1) = n;
      *r = x;
      *n = k;
      *(n + 1) = nx;
    } else {
      if (k <= v) {
        let n = malloc(2);
        *(x + 1) = n;
        *r = x;
        *n = v;
        *(n + 1) = nx;
        *x = k;
      } else {
        srtl_insert(nx, r);
        let y1 = *r;
        let y = malloc(2);
        free(x);
        *r = y;
        *(y + 1) = y1;
        *y = v;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/insertion-sort] sorted list: insert an element

[35m
[srtl/insertion-sort]:[0m
[0m[0m
[34mvoid insertion_sort(x loc, r loc) []
{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_5>}
{r :-> y ** sll(x, s, n)<_alpha_6> ** srtl(y, s, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 1561 milliseconds:[0m
[0mGoals generated: 282[0m
[0mGoals expanded: 256[0m
[0mAnd-nodes backtracked: 167[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 59[0m
[0mFinal memo size: (142,68,0)[0m
[0mFinal size of SMT cache: 80[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 23 times (113ms), failed 103 times (334ms)
CheckPost: succeeded 15 times (72ms), failed 26 times (24ms)
*Partial: succeeded 18 times (14ms), failed 149 times (50ms)
Close: succeeded 18 times (58ms), failed 7 times (0ms)
SubstR: succeeded 73 times (37ms), failed 119 times (6ms)
[0m
[0mSMTSolving          704ms
CyclicProofChecker  1ms  
                    705ms[0m
[0mvoid insertion_sort (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    insertion_sort(n, r);
    let y = *r;
    *r = v;
    srtl_insert(y, r);
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/sort] sort a list

[35m
[srtl/sort]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sort(x loc) []
{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2902 milliseconds:[0m
[0mGoals generated: 457[0m
[0mGoals expanded: 448[0m
[0mAnd-nodes backtracked: 309[0m
[0mMaximum worklist size: 11[0m
[0mMaximum goal depth: 65[0m
[0mFinal memo size: (245,126,0)[0m
[0mFinal size of SMT cache: 248[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 40 times (197ms), failed 176 times (594ms)
AbduceBranch: succeeded 59 times (566ms), failed 38 times (45ms)
Inconsistency: succeeded 5 times (17ms), failed 310 times (133ms)
SubstR: succeeded 108 times (75ms), failed 222 times (5ms)
Read: succeeded 6 times (8ms), failed 293 times (60ms)
[0m
[0mSMTSolving          1626ms
CyclicProofChecker  0ms   
                    1626ms[0m
[0m{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
void sort (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    sort(n);
    sort001609(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_0x < _alpha_3 && not (x == 0) && true ; (x + 1) :-> nxt ** x :-> vx ** srtl(nxt, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{srtl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void sort001609 (loc nxt, int vx, loc x) {
  if (nxt == 0) {
    *(x + 1) = 0;
  } else {
    let v = *nxt;
    let nx = *(nxt + 1);
    if (vx <= v) {
      let n = malloc(2);
      free(nxt);
      *(x + 1) = n;
      *n = v;
      *(n + 1) = nx;
    } else {
      *nxt = vx;
      sort001609(nx, vx, nxt);
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[multi-list/flatten] should be able to flatten a multi-list into a sll

[35m
[multi-list/flatten]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid multilist_flatten(r loc) []
{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> y ** sll(y, len, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1504 milliseconds:[0m
[0mGoals generated: 229[0m
[0mGoals expanded: 197[0m
[0mAnd-nodes backtracked: 47[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 81[0m
[0mFinal memo size: (46,134,0)[0m
[0mFinal size of SMT cache: 94[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 5 times (29ms), failed 107 times (345ms)
CheckPost: succeeded 18 times (111ms), failed 38 times (53ms)
Inconsistency: succeeded 0 times (0ms), failed 107 times (61ms)
SubstR: succeeded 43 times (32ms), failed 101 times (7ms)
Open: succeeded 11 times (34ms), failed 1 times (0ms)
[0m
[0mSMTSolving          717ms
CyclicProofChecker  0ms  
                    717ms[0m
[0m{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> y ** sll(y, len, s)<_alpha_4>}
void multilist_flatten (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let h = *x;
    let t = *(x + 1);
    *r = t;
    multilist_flatten(r);
    multilist_flatten118(h, x, r);
  }
}

{_alpha_1x1 < _alpha_3 && _alpha_2x1 < _alpha_3 && not (r == 0) && not (r == x) && not (x == 0) ; (x + 1) :-> tx11 ** r :-> y1 ** x :-> h ** sll(h, len1x1, s1x1)<_alpha_1x1>[0,1] ** sll(y1, size2x1, s2x1)<_alpha_41>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** sll(y, len1x1 + size2x1, s1x1 ++ s2x1)<_alpha_4>}
void multilist_flatten118 (loc h, loc x, loc r) {
  if (h == 0) {
    free(x);
  } else {
    let v = *h;
    let n = *(h + 1);
    *h = n;
    multilist_flatten118(n, h, r);
    let y = *r;
    *r = x;
    *(x + 1) = y;
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[multi-list/len] should be able to compute a length of a multi-list

[35m
[multi-list/len]:[0m
[0mmaxOpenDepth = 2, maxCloseDepth = 2[0m
[34mvoid multilist_length(r loc) []
{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> len ** multilist(x, len, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 8928 milliseconds:[0m
[0mGoals generated: 2504[0m
[0mGoals expanded: 2410[0m
[0mAnd-nodes backtracked: 1890[0m
[0mMaximum worklist size: 68[0m
[0mMaximum goal depth: 89[0m
[0mFinal memo size: (1696,204,0)[0m
[0mFinal size of SMT cache: 540[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 73 times (183ms), failed 1035 times (1523ms)
PureSynthesisFinal: succeeded 27 times (1684ms), failed 94 times (2ms)
CheckPost: succeeded 282 times (560ms), failed 307 times (117ms)
SubstR: succeeded 861 times (321ms), failed 1056 times (10ms)
Read: succeeded 24 times (13ms), failed 1568 times (262ms)
[0m
[0mSMTSolving          2398ms
CyclicProofChecker  0ms   
                    2398ms[0m
[0m{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> len ** multilist(x, len, s)<_alpha_4>}
void multilist_length (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    multilist_length10(x, r);
  }
}

{_alpha_1x1 < _alpha_3 && _alpha_2x1 < _alpha_3 && len == len1x1 + size2x1 && not (r == 0) && not (x == 0) && s =i s1x1 ++ s2x1 ; (x + 1) :-> tx1 ** r :-> x ** x :-> hx1 ** multilist(tx1, size2x1, s2x1)<_alpha_2x1>[0,1] ** sll(hx1, len1x1, s1x1)<_alpha_1x1>[0,1] ** [x, 2]}
{not (r == 0) ; r :-> len ** multilist(x, len, s)<_alpha_4>}
void multilist_length10 (loc x, loc r) {
  let hx = *x;
  let tx = *(x + 1);
  if (hx == 0) {
    *r = tx;
    multilist_length(r);
    *r = tx;
    multilist_length(r);
    *x = 0;
  } else {
    let v = *hx;
    let n = *(hx + 1);
    *(hx + 1) = tx;
    *hx = n;
    *r = hx;
    multilist_length10(hx, r);
    let l = *r;
    let h = *hx;
    let t = *(hx + 1);
    *(hx + 1) = h;
    *hx = v;
    *(x + 1) = t;
    *r = l + 1;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/free] should be able to deallocate a tree

[35m
[tree/free]:[0m
[0m[0m
[34mvoid tree_free(x loc) []
{tree(x, s)<_alpha_10>}
{emp}
[0m
[32mSuccessfully synthesised in 433 milliseconds:[0m
[0mGoals generated: 26[0m
[0mGoals expanded: 26[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 2[0m
[0mMaximum goal depth: 23[0m
[0mFinal memo size: (0,26,0)[0m
[0mFinal size of SMT cache: 11[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 0 times (0ms), failed 18 times (55ms)
FrameUnfold: succeeded 2 times (3ms), failed 5 times (18ms)
Inconsistency: succeeded 0 times (0ms), failed 9 times (21ms)
Open: succeeded 1 times (20ms), failed 2 times (0ms)
CheckPost: succeeded 0 times (0ms), failed 8 times (18ms)
[0m
[0mSMTSolving          240ms
CyclicProofChecker  0ms  
                    240ms[0m
[0mvoid tree_free (loc x) {
  if (x == 0) {
  } else {
    let l = *(x + 1);
    let r = *(x + 2);
    tree_free(l);
    tree_free(r);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/copy] should be able to synthesize a tree copy (with elements)

[35m
[tree/copy]:[0m
[0m[0m
[34mvoid tree_copy(r loc) []
{r :-> x ** tree(x, s)<_alpha_10>}
{r :-> y ** tree(x, s)<_alpha_11> ** tree(y, s)<_alpha_12>}
[0m
[32mSuccessfully synthesised in 3505 milliseconds:[0m
[0mGoals generated: 1061[0m
[0mGoals expanded: 982[0m
[0mAnd-nodes backtracked: 752[0m
[0mMaximum worklist size: 76[0m
[0mMaximum goal depth: 81[0m
[0mFinal memo size: (647,91,0)[0m
[0mFinal size of SMT cache: 246[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 30 times (85ms), failed 491 times (911ms)
CheckPost: succeeded 111 times (308ms), failed 101 times (19ms)
Read: succeeded 12 times (16ms), failed 614 times (134ms)
SubstR: succeeded 302 times (122ms), failed 489 times (9ms)
*Partial: succeeded 38 times (20ms), failed 626 times (91ms)
[0m
[0mSMTSolving          1408ms
CyclicProofChecker  0ms   
                    1408ms[0m
[0mvoid tree_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let rx = *(x + 2);
    *r = l;
    tree_copy(r);
    let y1 = *r;
    *r = rx;
    tree_copy(r);
    let y2 = *r;
    let y = malloc(3);
    *r = y;
    *(y + 1) = y1;
    *(y + 2) = y2;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[bst/insert] binary search tree: insert an element

[0mGoals generated: 2051[0m
[0mGoals expanded: 1821[0m
[0mAnd-nodes backtracked: 1166[0m
[0mMaximum worklist size: 197[0m
[0mMaximum goal depth: 71[0m
[0mFinal memo size: (985,128,490)[0m
[0mFinal size of SMT cache: 675[0m
[0mTime spent cycling: 3ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 89 times (230ms), failed 741 times (2219ms)
AbduceBranch: succeeded 216 times (2002ms), failed 79 times (66ms)
Read: succeeded 50 times (37ms), failed 1076 times (267ms)
SubstR: succeeded 521 times (234ms), failed 922 times (9ms)
Inconsistency: succeeded 5 times (16ms), failed 1162 times (187ms)
[0m
[0mSMTSolving          4584ms
CyclicProofChecker  3ms   
                    4587ms[0m
[bst/right-rotate] binary search tree: rotate right

[35m
[bst/right-rotate]:[0m
[0m[0m
[34mvoid bst_right_rotate(x loc, ret loc) []
{0 <= sz1 && 0 <= sz2 && not (l == 0) && upper s1 <= v && v == lower ([v] + s2) ; (x + 1) :-> l ** (x + 2) :-> r ** ret :-> unused ** x :-> v ** bst(l, s1, sz1)<_alpha_4> ** bst(r, s2, sz2)<_alpha_5> ** [x, 3]}
{sz3 + sz4 == sz1 + sz2 && v3 <= lower s4 && v3 == upper ([v3] + s3) ; (y + 1) :-> l3 ** (y + 2) :-> x ** ret :-> y ** y :-> v3 ** bst(l3, s3, sz3)<_alpha_6> ** bst(x, s4, sz4)<_alpha_7> ** [y, 3]}
[0m
[32mSuccessfully synthesised in 6583 milliseconds:[0m
[0mGoals generated: 1533[0m
[0mGoals expanded: 1484[0m
[0mAnd-nodes backtracked: 1390[0m
[0mMaximum worklist size: 52[0m
[0mMaximum goal depth: 63[0m
[0mFinal memo size: (1054,69,0)[0m
[0mFinal size of SMT cache: 392[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 26 times (155ms), failed 631 times (1540ms)
CheckPost: succeeded 339 times (1314ms), failed 71 times (65ms)
Read: succeeded 10 times (19ms), failed 950 times (403ms)
Inconsistency: succeeded 2 times (8ms), failed 1030 times (208ms)
*Partial: succeeded 70 times (56ms), failed 960 times (149ms)
[0m
[0mSMTSolving  3139ms
            3139ms[0m
[0mvoid bst_right_rotate (loc x, loc ret) {
  let l = *(x + 1);
  let r = *(l + 2);
  *(l + 2) = x;
  *(x + 1) = r;
  *ret = l;
}[0m
[0m-----------------------------------------------------[0m
[bst/max] binary search tree: find smallest element

[0mGoals generated: 1759[0m
[0mGoals expanded: 1681[0m
[0mAnd-nodes backtracked: 1250[0m
[0mMaximum worklist size: 132[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (959,8,373)[0m
[0mFinal size of SMT cache: 602[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 13 times (81ms), failed 796 times (2859ms)
CheckPost: succeeded 356 times (1222ms), failed 235 times (107ms)
SubstR: succeeded 459 times (222ms), failed 875 times (14ms)
Read: succeeded 14 times (14ms), failed 939 times (202ms)
Inconsistency: succeeded 0 times (0ms), failed 961 times (143ms)
[0m
[0mSMTSolving          4281ms
CyclicProofChecker  0ms   
                    4281ms[0m
[bst/delete-root] binary search tree: delete root

[0mGoals generated: 1389[0m
[0mGoals expanded: 1305[0m
[0mAnd-nodes backtracked: 1022[0m
[0mMaximum worklist size: 70[0m
[0mMaximum goal depth: 124[0m
[0mFinal memo size: (833,72,208)[0m
[0mFinal size of SMT cache: 600[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 32 times (195ms), failed 575 times (3337ms)
CheckPost: succeeded 244 times (1964ms), failed 141 times (345ms)
Inconsistency: succeeded 0 times (0ms), failed 849 times (297ms)
SubstR: succeeded 382 times (261ms), failed 581 times (8ms)
Read: succeeded 21 times (29ms), failed 776 times (207ms)
[0m
[0mSMTSolving          5957ms
CyclicProofChecker  0ms   
                    5957ms[0m
[bst/list-to-bst] covert a list into a BST

[0mGoals generated: 1516[0m
[0mGoals expanded: 1467[0m
[0mAnd-nodes backtracked: 1167[0m
[0mMaximum worklist size: 25[0m
[0mMaximum goal depth: 98[0m
[0mFinal memo size: (956,160,118)[0m
[0mFinal size of SMT cache: 754[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 42 times (205ms), failed 621 times (2521ms)
AbduceBranch: succeeded 245 times (2427ms), failed 90 times (71ms)
SubstR: succeeded 442 times (310ms), failed 670 times (12ms)
Read: succeeded 10 times (6ms), failed 959 times (283ms)
CheckPost: succeeded 25 times (206ms), failed 55 times (21ms)
[0m
[0mSMTSolving          5352ms
CyclicProofChecker  0ms   
                    5352ms[0m
[rose-tree/flatten] should be able to flatten a rose tree into a list

[0mGoals generated: 3827[0m
[0mGoals expanded: 3807[0m
[0mAnd-nodes backtracked: 3688[0m
[0mMaximum worklist size: 24[0m
[0mMaximum goal depth: 95[0m
[0mFinal memo size: (2296,30,89)[0m
[0mFinal size of SMT cache: 760[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 60 times (215ms), failed 1806 times (1612ms)
CheckPost: succeeded 1229 times (1546ms), failed 420 times (264ms)
Pick: succeeded 344 times (346ms), failed 7 times (1ms)
Read: succeeded 11 times (19ms), failed 1992 times (242ms)
*Partial: succeeded 53 times (31ms), failed 2003 times (158ms)
[0m
[0mSMTSolving          3351ms
CyclicProofChecker  0ms   
                    3351ms[0m
[packed/pack] 

[0mGoals generated: 2508[0m
[0mGoals expanded: 2168[0m
[0mAnd-nodes backtracked: 1202[0m
[0mMaximum worklist size: 459[0m
[0mMaximum goal depth: 26[0m
[0mFinal memo size: (977,1,856)[0m
[0mFinal size of SMT cache: 162[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 135 times (137ms), failed 798 times (1012ms)
Close: succeeded 532 times (455ms), failed 226 times (2ms)
*Partial: succeeded 189 times (76ms), failed 1474 times (217ms)
SubstR: succeeded 538 times (178ms), failed 933 times (45ms)
NilNotLval: succeeded 162 times (64ms), failed 1664 times (98ms)
[0m
[0mSMTSolving  1281ms
            1281ms[0m
[packed/unpack] 

[0mGoals generated: 2434[0m
[0mGoals expanded: 2126[0m
[0mAnd-nodes backtracked: 1322[0m
[0mMaximum worklist size: 327[0m
[0mMaximum goal depth: 90[0m
[0mFinal memo size: (1089,32,741)[0m
[0mFinal size of SMT cache: 470[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 284 times (681ms), failed 747 times (1391ms)
Close: succeeded 263 times (441ms), failed 36 times (1ms)
CheckPost: succeeded 86 times (312ms), failed 234 times (89ms)
Read: succeeded 44 times (24ms), failed 986 times (259ms)
SubstR: succeeded 502 times (244ms), failed 1065 times (24ms)
[0m
[0mSMTSolving          2548ms
CyclicProofChecker  1ms   
                    2549ms[0m
