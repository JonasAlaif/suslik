[ints/swap] should be able to synthesize a swap program

[35m
[ints/swap]:[0m
[0m[0m
[34mvoid swap(x loc, y loc) []
{x :-> a ** y :-> b}
{x :-> b ** y :-> a}
[0m
[32mSuccessfully synthesised in 269 milliseconds:[0m
[0mGoals generated: 12[0m
[0mGoals expanded: 10[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 3[0m
[0mMaximum goal depth: 9[0m
[0mFinal memo size: (0,10,0)[0m
[0mFinal size of SMT cache: 6[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 9 times (40ms)
*Partial: succeeded 1 times (18ms), failed 9 times (3ms)
CheckPost: succeeded 1 times (13ms), failed 3 times (4ms)
GhostWrite: succeeded 0 times (0ms), failed 3 times (16ms)
Read: succeeded 2 times (12ms), failed 4 times (1ms)
[0m
[0mSMTSolving  230ms
            230ms[0m
[0mvoid swap (loc x, loc y) {
  let a = *x;
  let b = *y;
  *y = a;
  *x = b;
}[0m
[0m-----------------------------------------------------[0m
[sll/len] singly-linked list: length

[35m
[sll/len]:[0m
[0m[0m
[34mvoid sll_len(x loc, ret loc) []
{0 <= n ; ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{ret :-> n ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 1097 milliseconds:[0m
[0mGoals generated: 126[0m
[0mGoals expanded: 109[0m
[0mAnd-nodes backtracked: 58[0m
[0mMaximum worklist size: 18[0m
[0mMaximum goal depth: 44[0m
[0mFinal memo size: (51,51,0)[0m
[0mFinal size of SMT cache: 65[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 7 times (47ms), failed 53 times (173ms)
CheckPost: succeeded 15 times (92ms), failed 20 times (36ms)
Inconsistency: succeeded 0 times (0ms), failed 61 times (95ms)
*Partial: succeeded 2 times (2ms), failed 61 times (27ms)
FrameUnfold: succeeded 4 times (6ms), failed 9 times (20ms)
[0m
[0mSMTSolving          603ms
CyclicProofChecker  0ms  
                    603ms[0m
[0mvoid sll_len (loc x, loc ret) {
  if (x == 0) {
    *ret = 0;
  } else {
    let n = *(x + 1);
    sll_len(n, ret);
    let l = *ret;
    *ret = l + 1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/max] singly-linked list: max

[35m
[sll/max]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sll_max(x loc, ret loc) []
{ret :-> a ** sll_bounded(x, n, s)<_alpha_3>}
{s == [] || m == upper s ; ret :-> m ** sll_bounded(x, n, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 5449 milliseconds:[0m
[0mGoals generated: 777[0m
[0mGoals expanded: 707[0m
[0mAnd-nodes backtracked: 356[0m
[0mMaximum worklist size: 28[0m
[0mMaximum goal depth: 82[0m
[0mFinal memo size: (300,301,0)[0m
[0mFinal size of SMT cache: 625[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 89 times (1343ms), failed 89 times (119ms)
PostInconsistent: succeeded 58 times (262ms), failed 295 times (1115ms)
Inconsistency: succeeded 14 times (36ms), failed 370 times (445ms)
SubstR: succeeded 164 times (101ms), failed 451 times (11ms)
*Partial: succeeded 14 times (13ms), failed 384 times (77ms)
[0m
[0mSMTSolving          3249ms
CyclicProofChecker  0ms   
                    3249ms[0m
[0mvoid sll_max (loc x, loc ret) {
  if (x == 0) {
  } else {
    let vx = *x;
    let nxt = *(x + 1);
    sll_max(nxt, ret);
    let m = *ret;
    if (m <= vx && vx <= m) {
    } else {
      if (vx <= m) {
        if (nxt == 0) {
          *ret = vx;
        } else {
          let v = *nxt;
          if (vx <= v && v <= vx) {
            let nx = *(nxt + 1);
            let n = malloc(2);
            free(nxt);
            *(x + 1) = n;
            *n = m;
            *(n + 1) = nx;
          } else {
            if (vx <= v) {
              let nx = *(nxt + 1);
              let n = malloc(2);
              free(nxt);
              *(x + 1) = n;
              *n = m;
              *(n + 1) = nx;
            } else {
              let nx = *(nxt + 1);
              let n = malloc(2);
              free(nxt);
              *(x + 1) = n;
              *x = v;
              *n = m;
              *(n + 1) = nx;
            }
          }
        }
      } else {
        *ret = vx;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/free] should be able to deallocate a linked list

[35m
[sll/free]:[0m
[0m[0m
[34mvoid sll_free(x loc) []
{sll(x, s)<_alpha_3>}
{emp}
[0m
[32mSuccessfully synthesised in 338 milliseconds:[0m
[0mGoals generated: 16[0m
[0mGoals expanded: 17[0m
[0mAnd-nodes backtracked: 0[0m
[0mMaximum worklist size: 1[0m
[0mMaximum goal depth: 14[0m
[0mFinal memo size: (0,17,0)[0m
[0mFinal size of SMT cache: 9[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 11 times (53ms)
Open: succeeded 1 times (20ms), failed 1 times (0ms)
*Partial: succeeded 0 times (0ms), failed 11 times (14ms)
CheckPost: succeeded 0 times (0ms), failed 5 times (13ms)
GhostWrite: succeeded 0 times (0ms), failed 3 times (13ms)
[0m
[0mSMTSolving          215ms
CyclicProofChecker  0ms  
                    215ms[0m
[0mvoid sll_free (loc x) {
  if (x == 0) {
  } else {
    let n = *(x + 1);
    sll_free(n);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/copy] should be able to synthesize list copy

[35m
[sll/copy]:[0m
[0m[0m
[34mvoid sll_copy(r loc) []
{r :-> x ** sll(x, s)<a>}
{r :-> y ** sll(x, s)<a> ** sll(y, s)<b>}
[0m
[32mSuccessfully synthesised in 1213 milliseconds:[0m
[0mGoals generated: 189[0m
[0mGoals expanded: 165[0m
[0mAnd-nodes backtracked: 99[0m
[0mMaximum worklist size: 21[0m
[0mMaximum goal depth: 54[0m
[0mFinal memo size: (86,64,0)[0m
[0mFinal size of SMT cache: 73[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 12 times (88ms), failed 77 times (204ms)
CheckPost: succeeded 15 times (113ms), failed 19 times (16ms)
Inconsistency: succeeded 0 times (0ms), failed 89 times (58ms)
*Partial: succeeded 12 times (13ms), failed 89 times (27ms)
Close: succeeded 12 times (38ms), failed 6 times (0ms)
[0m
[0mSMTSolving          604ms
CyclicProofChecker  1ms  
                    605ms[0m
[0mvoid sll_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    sll_copy(r);
    let y1 = *r;
    let y = malloc(2);
    *r = y;
    *(y + 1) = y1;
    *y = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/append] singly-linked list: append

[35m
[sll/append]:[0m
[0m[0m
[34mvoid sll_append(x1 loc, ret loc) []
{ret :-> x2 ** sll(x1, s1)<_alpha_3> ** sll(x2, s2)<_alpha_4>}
{s == s1 + s2 ; ret :-> y ** sll(y, s)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 1786 milliseconds:[0m
[0mGoals generated: 320[0m
[0mGoals expanded: 294[0m
[0mAnd-nodes backtracked: 137[0m
[0mMaximum worklist size: 19[0m
[0mMaximum goal depth: 49[0m
[0mFinal memo size: (129,121,0)[0m
[0mFinal size of SMT cache: 174[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 14 times (52ms), failed 149 times (274ms)
CheckPost: succeeded 41 times (269ms), failed 45 times (42ms)
Inconsistency: succeeded 0 times (0ms), failed 183 times (198ms)
*Partial: succeeded 18 times (11ms), failed 183 times (45ms)
SubstR: succeeded 52 times (39ms), failed 210 times (1ms)
[0m
[0mSMTSolving          950ms
CyclicProofChecker  0ms  
                    950ms[0m
[0mvoid sll_append (loc x1, loc ret) {
  if (x1 == 0) {
  } else {
    let n = *(x1 + 1);
    sll_append(n, ret);
    let y = *ret;
    *ret = x1;
    *(x1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/free2] Deallocate two linked lists (needs listfree as an auxiliary, unless we can pass emp as a list)

[35m
[sll/free2]:[0m
[0m[0m
[34mvoid listfree2(x loc, y loc) []
{sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4>}
{emp}
[0m
[32mSuccessfully synthesised in 699 milliseconds:[0m
[0mGoals generated: 68[0m
[0mGoals expanded: 70[0m
[0mAnd-nodes backtracked: 4[0m
[0mMaximum worklist size: 4[0m
[0mMaximum goal depth: 19[0m
[0mFinal memo size: (4,59,0)[0m
[0mFinal size of SMT cache: 30[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 42 times (176ms)
Open: succeeded 5 times (35ms), failed 4 times (0ms)
CheckPost: succeeded 0 times (0ms), failed 15 times (30ms)
AbduceCall: succeeded 4 times (12ms), failed 5 times (11ms)
*Partial: succeeded 0 times (0ms), failed 42 times (18ms)
[0m
[0mSMTSolving          352ms
CyclicProofChecker  0ms  
                    352ms[0m
[0mvoid listfree2 (loc x, loc y) {
  if (x == 0) {
    listfree200(y);
  } else {
    let n = *(x + 1);
    listfree2(n, y);
    free(x);
  }
}

void listfree200 (loc y) {
  if (y == 0) {
  } else {
    let n = *(y + 1);
    listfree200(n);
    free(y);
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/multi-append] append multiple lists

[35m
[sll/multi-append]:[0m
[0m[0m
[34mvoid append3(x loc, y loc, z loc, r loc) []
{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
[0m
[32mSuccessfully synthesised in 3170 milliseconds:[0m
[0mGoals generated: 856[0m
[0mGoals expanded: 759[0m
[0mAnd-nodes backtracked: 288[0m
[0mMaximum worklist size: 37[0m
[0mMaximum goal depth: 57[0m
[0mFinal memo size: (270,386,0)[0m
[0mFinal size of SMT cache: 399[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 25 times (69ms), failed 387 times (541ms)
CheckPost: succeeded 109 times (480ms), failed 121 times (71ms)
Inconsistency: succeeded 0 times (0ms), failed 453 times (457ms)
*Partial: succeeded 56 times (23ms), failed 453 times (52ms)
Read: succeeded 41 times (22ms), failed 296 times (40ms)
[0m
[0mSMTSolving          1680ms
CyclicProofChecker  0ms   
                    1680ms[0m
[0m{r :-> a ** sll(x, s1)<_alpha_3> ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{s == (s1 + s2) + s3 ; r :-> v ** sll(v, s)<_alpha_6>}
void append3 (loc x, loc y, loc z, loc r) {
  if (x == 0) {
    append300(y, z, r);
  } else {
    let n = *(x + 1);
    append3(n, y, z, r);
    let v = *r;
    *r = x;
    *(x + 1) = v;
  }
}

{not (r == 0) && s1 =i {} && x == 0 ; r :-> a1 ** sll(y, s2)<_alpha_4> ** sll(z, s3)<_alpha_5>}
{not (r == 0) ; r :-> v ** sll(v, s1 ++ s2 ++ s3)<_alpha_6>}
void append300 (loc y, loc z, loc r) {
  if (y == 0) {
    if (z == 0) {
      *r = 0;
    } else {
      let vz = *z;
      let n = *(z + 1);
      let v = malloc(2);
      free(z);
      *r = v;
      *v = vz;
      *(v + 1) = n;
    }
  } else {
    let vy = *y;
    let n = *(y + 1);
    append300(n, z, r);
    let v1 = *r;
    let v = malloc(2);
    free(y);
    *r = v;
    *v = vy;
    *(v + 1) = v1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/append-copy] append multiple lists

[35m
[sll/append-copy]:[0m
[0m[0m
[34mvoid sll_append_copy(x1 loc, r loc) []
{r :-> x2 ** sll(x1, s1)<_alpha_3> ** sll(x2, s2)<_alpha_4>}
{s == s1 + s2 ; r :-> y ** sll(x1, s1)<_alpha_5> ** sll(x2, s2)<_alpha_6> ** sll(y, s)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 5429 milliseconds:[0m
[0mGoals generated: 2084[0m
[0mGoals expanded: 2037[0m
[0mAnd-nodes backtracked: 1819[0m
[0mMaximum worklist size: 48[0m
[0mMaximum goal depth: 65[0m
[0mFinal memo size: (1520,136,0)[0m
[0mFinal size of SMT cache: 561[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 154 times (524ms), failed 742 times (1363ms)
CheckPost: succeeded 123 times (415ms), failed 49 times (24ms)
SubstR: succeeded 617 times (184ms), failed 1073 times (53ms)
Close: succeeded 115 times (146ms), failed 39 times (0ms)
FrameUnfold: succeeded 247 times (81ms), failed 300 times (32ms)
[0m
[0mSMTSolving          2470ms
CyclicProofChecker  0ms   
                    2470ms[0m
[0m{r :-> x2 ** sll(x1, s1)<_alpha_3> ** sll(x2, s2)<_alpha_4>}
{s == s1 + s2 ; r :-> y ** sll(x1, s1)<_alpha_5> ** sll(x2, s2)<_alpha_6> ** sll(y, s)<_alpha_7>}
void sll_append_copy (loc x1, loc r) {
  let x = *r;
  if (x1 == 0) {
    sll_append_copy00(x, r);
  } else {
    let v = *x1;
    let n = *(x1 + 1);
    sll_append_copy(n, r);
    let y1 = *r;
    let y = malloc(2);
    *r = y;
    *(y + 1) = y1;
    *y = v;
  }
}

{not (r == 0) && s1 =i {} && x1 == 0 ; r :-> x ** sll(x, s2)<_alpha_4>}
{not (r == 0) ; r :-> y ** sll(x, s2)<_alpha_6> ** sll(x1, s1)<_alpha_5> ** sll(y, s1 ++ s2)<_alpha_7>}
void sll_append_copy00 (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    sll_append_copy00(n, r);
    let y1 = *r;
    let y = malloc(2);
    *r = y;
    *y = v;
    *(y + 1) = y1;
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/union] union of two unique lists

[0mGoals generated: 4048[0m
[0mGoals expanded: 4004[0m
[0mAnd-nodes backtracked: 3521[0m
[0mMaximum worklist size: 26[0m
[0mMaximum goal depth: 79[0m
[0mFinal memo size: (2480,287,177)[0m
[0mFinal size of SMT cache: 1549[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 1026 times (3352ms), failed 463 times (277ms)
PostInconsistent: succeeded 309 times (526ms), failed 1799 times (1864ms)
Inconsistency: succeeded 14 times (44ms), failed 2186 times (835ms)
Pick: succeeded 332 times (375ms), failed 51 times (3ms)
Read: succeeded 29 times (19ms), failed 1712 times (318ms)
[0m
[0mSMTSolving          6107ms
CyclicProofChecker  0ms   
                    6107ms[0m
[sll/diff] difference of two unique lists

[35m
[sll/diff]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid diff(r loc, y loc) []
{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 - s2)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 10353 milliseconds:[0m
[0mGoals generated: 2356[0m
[0mGoals expanded: 2331[0m
[0mAnd-nodes backtracked: 1976[0m
[0mMaximum worklist size: 23[0m
[0mMaximum goal depth: 102[0m
[0mFinal memo size: (1596,281,0)[0m
[0mFinal size of SMT cache: 1234[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 437 times (2160ms), failed 243 times (172ms)
PostInconsistent: succeeded 188 times (465ms), failed 1054 times (1776ms)
Inconsistency: succeeded 17 times (41ms), failed 1210 times (750ms)
CheckPost: succeeded 36 times (185ms), failed 76 times (55ms)
*Partial: succeeded 72 times (37ms), failed 1227 times (156ms)
[0m
[0mSMTSolving          5170ms
CyclicProofChecker  0ms   
                    5170ms[0m
[0m{r :-> x ** ulist(x, s1)<_alpha_3> ** ulist(y, s2)<_alpha_4>}
{r :-> z ** ulist(z, s1 - s2)<_alpha_5>}
void diff (loc r, loc y) {
  if (y == 0) {
  } else {
    let v = *y;
    let n = *(y + 1);
    diff(r, n);
    diff02011302016(v, r, y);
  }
}

{_alpha_1y < _alpha_4 && not (r == 0) && not (r == y) && not (vy in s1y) && not (y == 0) && true ; (y + 1) :-> nxty1 ** r :-> z1 ** y :-> vy ** ulist(z1, s1 -- s1y)<_alpha_51>[1,0] ** [y, 2]}
{not (r == 0) ; r :-> z ** ulist(z, s1 -- ({vy} ++ s1y))<_alpha_5>}
void diff02011302016 (int vy, loc r, loc y) {
  let z1 = *r;
  if (z1 == 0) {
    free(y);
  } else {
    let v = *z1;
    if (vy <= v && v <= vy) {
      let n = *(z1 + 1);
      *r = n;
      diff02011302016(v, r, z1);
      free(y);
    } else {
      let n = *(z1 + 1);
      *r = n;
      *z1 = vy;
      diff02011302016(vy, r, z1);
      let z2 = *r;
      let z = malloc(2);
      free(y);
      *r = z;
      *z = v;
      *(z + 1) = z2;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[sll/unique] deduplicate a list

[35m
[sll/unique]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid unique(r loc) []
{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 7300 milliseconds:[0m
[0mGoals generated: 1767[0m
[0mGoals expanded: 1756[0m
[0mAnd-nodes backtracked: 1545[0m
[0mMaximum worklist size: 16[0m
[0mMaximum goal depth: 97[0m
[0mFinal memo size: (1088,189,0)[0m
[0mFinal size of SMT cache: 865[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 448 times (2098ms), failed 197 times (116ms)
PostInconsistent: succeeded 138 times (245ms), failed 790 times (890ms)
Inconsistency: succeeded 15 times (50ms), failed 945 times (380ms)
Read: succeeded 12 times (15ms), failed 738 times (145ms)
Pick: succeeded 143 times (148ms), failed 22 times (0ms)
[0m
[0mSMTSolving          3479ms
CyclicProofChecker  0ms   
                    3479ms[0m
[0m{r :-> x ** sll(x, s)<_alpha_3>}
{r :-> y ** ulist(y, s)<_alpha_4>}
void unique (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    *r = n;
    unique(r);
    unique02011302011(v, x, r);
  }
}

{_alpha_0x1 < _alpha_3 && not (r == 0) && not (r == x) && not (x == 0) && true ; (x + 1) :-> nxtx11 ** r :-> y1 ** x :-> vx ** ulist(y1, s1x1)<_alpha_41>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** ulist(y, {vx} ++ s1x1)<_alpha_4>}
void unique02011302011 (int vx, loc x, loc r) {
  let y1 = *r;
  if (y1 == 0) {
    let y = malloc(2);
    free(x);
    *r = y;
    *y = vx;
    *(y + 1) = 0;
  } else {
    let v = *y1;
    if (vx <= v && v <= vx) {
      let n = *(y1 + 1);
      let y = malloc(2);
      free(y1);
      free(x);
      *r = y;
      *y = vx;
      *(y + 1) = n;
    } else {
      let n = *(y1 + 1);
      *r = n;
      *y1 = vx;
      unique02011302011(vx, y1, r);
      let y2 = *r;
      let y = malloc(2);
      free(x);
      *r = y;
      *y = v;
      *(y + 1) = y2;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/prepend] sorted list: prepend an element

[35m
[srtl/prepend]:[0m
[0m[0m
[34mvoid srtl_prepend(x loc, k int, r loc) []
{0 <= n && k == lower (s + [k]) ; r :-> a ** srtl(x, s, n)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], n + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 573 milliseconds:[0m
[0mGoals generated: 46[0m
[0mGoals expanded: 37[0m
[0mAnd-nodes backtracked: 10[0m
[0mMaximum worklist size: 10[0m
[0mMaximum goal depth: 26[0m
[0mFinal memo size: (9,27,0)[0m
[0mFinal size of SMT cache: 26[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
CheckPost: succeeded 5 times (77ms), failed 8 times (23ms)
PostInconsistent: succeeded 2 times (16ms), failed 20 times (63ms)
Inconsistency: succeeded 0 times (0ms), failed 23 times (37ms)
FrameUnfold: succeeded 1 times (2ms), failed 2 times (17ms)
NilNotLval: succeeded 2 times (9ms), failed 18 times (7ms)
[0m
[0mSMTSolving  378ms
            378ms[0m
[0mvoid srtl_prepend (loc x, int k, loc r) {
  let y = malloc(2);
  *r = y;
  *(y + 1) = x;
  *y = k;
}[0m
[0m-----------------------------------------------------[0m
[srtl/insert] sorted list: insert an element

[35m
[srtl/insert]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid srtl_insert(x loc, r loc) [k int]
{0 <= l ; r :-> k ** srtl(x, s, l)<_alpha_3>}
{r :-> y ** srtl(y, s + [k], l + 1)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 4066 milliseconds:[0m
[0mGoals generated: 733[0m
[0mGoals expanded: 721[0m
[0mAnd-nodes backtracked: 538[0m
[0mMaximum worklist size: 12[0m
[0mMaximum goal depth: 60[0m
[0mFinal memo size: (403,183,0)[0m
[0mFinal size of SMT cache: 471[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 183 times (1087ms), failed 89 times (92ms)
PostInconsistent: succeeded 36 times (154ms), failed 329 times (705ms)
Inconsistency: succeeded 11 times (32ms), failed 386 times (313ms)
Read: succeeded 6 times (10ms), failed 308 times (71ms)
*Partial: succeeded 18 times (13ms), failed 397 times (65ms)
[0m
[0mSMTSolving          2310ms
CyclicProofChecker  0ms   
                    2310ms[0m
[0mvoid srtl_insert (loc x, loc r) {
  let k = *r;
  if (x == 0) {
    let y = malloc(2);
    *r = y;
    *y = lower ([] ++ [k]);
    *(y + 1) = 0;
  } else {
    let v = *x;
    if (v <= k && k <= v) {
      let nx = *(x + 1);
      let n = malloc(2);
      *(x + 1) = n;
      *r = x;
      *n = k;
      *(n + 1) = nx;
    } else {
      if (k <= v) {
        let nx = *(x + 1);
        let n = malloc(2);
        *(x + 1) = n;
        *x = k;
        *r = x;
        *n = v;
        *(n + 1) = nx;
      } else {
        let n = *(x + 1);
        srtl_insert(n, r);
        let y1 = *r;
        let y = malloc(2);
        free(x);
        *r = y;
        *y = v;
        *(y + 1) = y1;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/insertion-sort] sorted list: insert an element

[35m
[srtl/insertion-sort]:[0m
[0m[0m
[34mvoid insertion_sort(x loc, r loc) []
{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_5>}
{r :-> y ** sll(x, s, n)<_alpha_6> ** srtl(y, s, n)<_alpha_7>}
[0m
[32mSuccessfully synthesised in 2254 milliseconds:[0m
[0mGoals generated: 560[0m
[0mGoals expanded: 512[0m
[0mAnd-nodes backtracked: 306[0m
[0mMaximum worklist size: 35[0m
[0mMaximum goal depth: 67[0m
[0mFinal memo size: (259,112,0)[0m
[0mFinal size of SMT cache: 159[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 61 times (215ms), failed 176 times (330ms)
Inconsistency: succeeded 3 times (11ms), failed 204 times (221ms)
CheckPost: succeeded 24 times (106ms), failed 56 times (54ms)
Close: succeeded 42 times (88ms), failed 17 times (0ms)
SubstR: succeeded 137 times (62ms), failed 327 times (13ms)
[0m
[0mSMTSolving          1027ms
CyclicProofChecker  0ms   
                    1027ms[0m
[0mvoid insertion_sort (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    insertion_sort(n, r);
    let y = *r;
    *r = v;
    srtl_insert(y, r);
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/sort] sort a list

[35m
[srtl/sort]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid sort(x loc) []
{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2965 milliseconds:[0m
[0mGoals generated: 481[0m
[0mGoals expanded: 469[0m
[0mAnd-nodes backtracked: 315[0m
[0mMaximum worklist size: 13[0m
[0mMaximum goal depth: 67[0m
[0mFinal memo size: (251,140,0)[0m
[0mFinal size of SMT cache: 268[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 39 times (148ms), failed 184 times (486ms)
AbduceBranch: succeeded 67 times (568ms), failed 45 times (43ms)
Inconsistency: succeeded 8 times (20ms), failed 230 times (286ms)
SubstR: succeeded 112 times (70ms), failed 275 times (11ms)
Close: succeeded 19 times (57ms), failed 10 times (0ms)
[0m
[0mSMTSolving          1630ms
CyclicProofChecker  1ms   
                    1631ms[0m
[0m{0 <= n ; sll(x, s, n)<_alpha_3>}
{srtl(x, s, n)<_alpha_4>}
void sort (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    sort(n);
    sort001302010(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_0x < _alpha_3 && not (x == 0) && true ; (x + 1) :-> nxt ** x :-> vx ** srtl(nxt, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{srtl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void sort001302010 (loc nxt, int vx, loc x) {
  if (nxt == 0) {
  } else {
    let v = *nxt;
    if (vx <= v) {
      let nx = *(nxt + 1);
      let n = malloc(2);
      free(nxt);
      *(x + 1) = n;
      *n = v;
      *(n + 1) = nx;
    } else {
      let n = *(nxt + 1);
      *nxt = vx;
      sort001302010(n, vx, nxt);
      *x = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/reverse] reverse a list

[35m
[srtl/reverse]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid reverse(x loc) []
{0 <= n ; srtl(x, s, n)<_alpha_3>}
{descl(x, s, n)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2124 milliseconds:[0m
[0mGoals generated: 353[0m
[0mGoals expanded: 340[0m
[0mAnd-nodes backtracked: 255[0m
[0mMaximum worklist size: 20[0m
[0mMaximum goal depth: 60[0m
[0mFinal memo size: (198,85,0)[0m
[0mFinal size of SMT cache: 154[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 12 times (56ms), failed 159 times (474ms)
CheckPost: succeeded 77 times (348ms), failed 46 times (72ms)
Inconsistency: succeeded 0 times (0ms), failed 164 times (129ms)
SubstR: succeeded 76 times (57ms), failed 195 times (8ms)
*Partial: succeeded 6 times (8ms), failed 164 times (45ms)
[0m
[0mSMTSolving          1168ms
CyclicProofChecker  0ms   
                    1168ms[0m
[0m{0 <= n ; srtl(x, s, n)<_alpha_3>}
{descl(x, s, n)<_alpha_4>}
void reverse (loc x) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    reverse(n);
    reverse115(n, v, x);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_1x < _alpha_3 && not (x == 0) && vx == lower ([vx] ++ s1x) ; (x + 1) :-> nx ** x :-> vx ** descl(nx, s1x, len1x)<_alpha_41>[1,0] ** [x, 2]}
{descl(x, [vx] ++ s1x, len1x + 1)<_alpha_4>}
void reverse115 (loc nx, int vx, loc x) {
  if (nx == 0) {
  } else {
    let v = *nx;
    let n = *(nx + 1);
    *nx = vx;
    reverse115(n, vx, nx);
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[srtl/merge] sorted list: merge

[0mGoals generated: 2600[0m
[0mGoals expanded: 2546[0m
[0mAnd-nodes backtracked: 2064[0m
[0mMaximum worklist size: 21[0m
[0mMaximum goal depth: 93[0m
[0mFinal memo size: (1612,333,124)[0m
[0mFinal size of SMT cache: 1065[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 711 times (3603ms), failed 291 times (374ms)
PostInconsistent: succeeded 76 times (351ms), failed 1235 times (2791ms)
Inconsistency: succeeded 10 times (35ms), failed 1381 times (1259ms)
Read: succeeded 27 times (24ms), failed 1152 times (351ms)
Pick: succeeded 158 times (248ms), failed 59 times (2ms)
[0m
[0mSMTSolving          7802ms
CyclicProofChecker  0ms   
                    7802ms[0m
[dll/copy] should be able to synthesize list copy

[35m
[dll/copy]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid dll_copy(r loc) []
{r :-> x ** dll(x, a, s)<_alpha_2>}
{r :-> y ** dll(x, a, s)<_alpha_3> ** dll(y, b, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 9025 milliseconds:[0m
[0mGoals generated: 4803[0m
[0mGoals expanded: 4665[0m
[0mAnd-nodes backtracked: 4410[0m
[0mMaximum worklist size: 117[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (3024,166,0)[0m
[0mFinal size of SMT cache: 558[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 187 times (419ms), failed 1852 times (1309ms)
CheckPost: succeeded 1003 times (701ms), failed 418 times (67ms)
SubstR: succeeded 1007 times (254ms), failed 2194 times (41ms)
Read: succeeded 15 times (11ms), failed 1824 times (240ms)
*Partial: succeeded 129 times (43ms), failed 2057 times (161ms)
[0m
[0mSMTSolving          2514ms
CyclicProofChecker  0ms   
                    2514ms[0m
[0mvoid dll_copy (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let vx = *x;
    let w = *(x + 1);
    let a = *(x + 2);
    *r = w;
    dll_copy(r);
    let y1 = *r;
    if (y1 == 0) {
      let y = malloc(3);
      *r = y;
      *y = vx;
      *(y + 1) = 0;
      *(y + 2) = a;
    } else {
      let v = *y1;
      let y = malloc(3);
      *(y1 + 2) = y;
      *r = y;
      *(y + 1) = y1;
      *(y + 2) = a;
      *y1 = vx;
      *y = v;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[dll/append] doubly-linked list: append

[35m
[dll/append]:[0m
[0mmaxCloseDepth = 2[0m
[34mvoid dll_append(x1 loc, ret loc) []
{ret :-> x2 ** dll(x1, a, s1)<_alpha_2> ** dll(x2, b, s2)<_alpha_3>}
{s == s1 + s2 ; ret :-> y ** dll(y, c, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 4444 milliseconds:[0m
[0mGoals generated: 1874[0m
[0mGoals expanded: 1738[0m
[0mAnd-nodes backtracked: 1366[0m
[0mMaximum worklist size: 77[0m
[0mMaximum goal depth: 76[0m
[0mFinal memo size: (913,234,0)[0m
[0mFinal size of SMT cache: 377[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 42 times (119ms), failed 802 times (711ms)
CheckPost: succeeded 401 times (530ms), failed 223 times (72ms)
Inconsistency: succeeded 0 times (0ms), failed 866 times (366ms)
SubstR: succeeded 265 times (97ms), failed 948 times (14ms)
Read: succeeded 35 times (19ms), failed 733 times (84ms)
[0m
[0mSMTSolving          1769ms
CyclicProofChecker  0ms   
                    1769ms[0m
[0mvoid dll_append (loc x1, loc ret) {
  if (x1 == 0) {
  } else {
    let v = *x1;
    let w = *(x1 + 1);
    let a = *(x1 + 2);
    dll_append(w, ret);
    let y1 = *ret;
    if (y1 == 0) {
      let y = malloc(3);
      free(x1);
      *ret = y;
      *y = v;
      *(y + 1) = 0;
      *(y + 2) = a;
    } else {
      *(y1 + 2) = x1;
      *ret = x1;
      *(x1 + 1) = y1;
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[dll/delete-all] doubly-linked list: delete all occurrences of x

[35m
[dll/delete-all]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid dll_delete_all(x loc, ret loc) []
{ret :-> a ** dll(x, b, s)<_alpha_2>}
{s1 == s - {a} ; ret :-> y ** dll(y, c, s1)<_alpha_3>}
[0m
[32mSuccessfully synthesised in 9591 milliseconds:[0m
[0mGoals generated: 4373[0m
[0mGoals expanded: 4344[0m
[0mAnd-nodes backtracked: 4107[0m
[0mMaximum worklist size: 20[0m
[0mMaximum goal depth: 84[0m
[0mFinal memo size: (2388,216,0)[0m
[0mFinal size of SMT cache: 677[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 1005 times (1830ms), failed 484 times (98ms)
PostInconsistent: succeeded 464 times (263ms), failed 1631 times (847ms)
Inconsistency: succeeded 17 times (47ms), failed 2130 times (413ms)
Pick: succeeded 438 times (307ms), failed 31 times (1ms)
Read: succeeded 18 times (16ms), failed 1589 times (268ms)
[0m
[0mSMTSolving          3009ms
CyclicProofChecker  0ms   
                    3009ms[0m
[0mvoid dll_delete_all (loc x, loc ret) {
  let a = *ret;
  if (x == 0) {
    *ret = 0;
  } else {
    let vx = *x;
    if (a <= vx && vx <= a) {
      let w = *(x + 1);
      dll_delete_all(w, ret);
      free(x);
    } else {
      let w = *(x + 1);
      let b = *(x + 2);
      dll_delete_all(w, ret);
      let y1 = *ret;
      if (y1 == 0) {
        let y = malloc(3);
        free(x);
        *ret = y;
        *y = vx;
        *(y + 1) = 0;
        *(y + 2) = b;
      } else {
        let v = *y1;
        if (vx <= v && v <= vx) {
          free(x);
          *(y1 + 2) = b;
        } else {
          let y = malloc(3);
          free(x);
          *(y1 + 2) = y;
          *y1 = vx;
          *ret = y;
          *y = v;
          *(y + 1) = y1;
          *(y + 2) = b;
        }
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[multi-list/free] should be able to deallocate a multi-list

[35m
[multi-list/free]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid multilist_free(x loc) []
{multilist(x, len, s)<_alpha_3>}
{emp}
[0m
[32mSuccessfully synthesised in 811 milliseconds:[0m
[0mGoals generated: 76[0m
[0mGoals expanded: 72[0m
[0mAnd-nodes backtracked: 2[0m
[0mMaximum worklist size: 8[0m
[0mMaximum goal depth: 42[0m
[0mFinal memo size: (2,62,0)[0m
[0mFinal size of SMT cache: 34[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 37 times (141ms)
CheckPost: succeeded 3 times (24ms), failed 19 times (59ms)
PostInconsistent: succeeded 0 times (0ms), failed 37 times (43ms)
Open: succeeded 5 times (34ms), failed 1 times (0ms)
*Partial: succeeded 2 times (3ms), failed 37 times (19ms)
[0m
[0mSMTSolving          407ms
CyclicProofChecker  0ms  
                    407ms[0m
[0m{multilist(x, len, s)<_alpha_3>}
{emp}
void multilist_free (loc x) {
  if (x == 0) {
  } else {
    let h = *x;
    let t = *(x + 1);
    multilist_free(t);
    multilist_free114(h, x);
  }
}

{_alpha_1x < _alpha_3 && _alpha_2x < _alpha_3 && not (x == 0) ; (x + 1) :-> tx1 ** x :-> h ** sll(h, len1x, s1x)<_alpha_1x>[0,1] ** [x, 2]}
{emp}
void multilist_free114 (loc h, loc x) {
  if (h == 0) {
    free(x);
  } else {
    let n = *(h + 1);
    *h = n;
    multilist_free114(n, h);
    free(x);
  }
}[0m
[0m-----------------------------------------------------[0m
[multi-list/flatten] should be able to flatten a multi-list into a sll

[35m
[multi-list/flatten]:[0m
[0mmaxOpenDepth = 2[0m
[34mvoid multilist_flatten(r loc) []
{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> y ** sll(y, len, s)<_alpha_4>}
[0m
[32mSuccessfully synthesised in 2086 milliseconds:[0m
[0mGoals generated: 398[0m
[0mGoals expanded: 352[0m
[0mAnd-nodes backtracked: 106[0m
[0mMaximum worklist size: 22[0m
[0mMaximum goal depth: 82[0m
[0mFinal memo size: (102,229,0)[0m
[0mFinal size of SMT cache: 167[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 17 times (59ms), failed 169 times (305ms)
CheckPost: succeeded 35 times (228ms), failed 60 times (67ms)
Inconsistency: succeeded 0 times (0ms), failed 203 times (267ms)
*Partial: succeeded 23 times (19ms), failed 203 times (50ms)
SubstR: succeeded 69 times (42ms), failed 265 times (9ms)
[0m
[0mSMTSolving          1033ms
CyclicProofChecker  0ms   
                    1033ms[0m
[0m{r :-> x ** multilist(x, len, s)<_alpha_3>}
{r :-> y ** sll(y, len, s)<_alpha_4>}
void multilist_flatten (loc r) {
  let x = *r;
  if (x == 0) {
  } else {
    let h = *x;
    let t = *(x + 1);
    *r = t;
    multilist_flatten(r);
    multilist_flatten118(h, x, r);
  }
}

{_alpha_1x1 < _alpha_3 && _alpha_2x1 < _alpha_3 && not (r == 0) && not (r == x) && not (x == 0) ; (x + 1) :-> tx11 ** r :-> y1 ** x :-> h ** sll(h, len1x1, s1x1)<_alpha_1x1>[0,1] ** sll(y1, size2x1, s2x1)<_alpha_41>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** sll(y, len1x1 + size2x1, s1x1 ++ s2x1)<_alpha_4>}
void multilist_flatten118 (loc h, loc x, loc r) {
  let y1 = *r;
  if (h == 0) {
    if (y1 == 0) {
      free(x);
    } else {
      let v = *y1;
      let n = *(y1 + 1);
      let y = malloc(2);
      free(y1);
      free(x);
      *r = y;
      *y = v;
      *(y + 1) = n;
    }
  } else {
    let v = *h;
    let n = *(h + 1);
    *h = n;
    multilist_flatten118(n, h, r);
    let y = *r;
    *r = x;
    *(x + 1) = y;
    *x = v;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/free2] Deallocate two trees

[35m
[tree/free2]:[0m
[0m[0m
[34mvoid treefree2(x loc, y loc) []
{tree(x, s1)<_alpha_10> ** tree(y, s2)<_alpha_11>}
{emp}
[0m
[32mSuccessfully synthesised in 1150 milliseconds:[0m
[0mGoals generated: 213[0m
[0mGoals expanded: 209[0m
[0mAnd-nodes backtracked: 58[0m
[0mMaximum worklist size: 10[0m
[0mMaximum goal depth: 43[0m
[0mFinal memo size: (54,99,0)[0m
[0mFinal size of SMT cache: 45[0m
[0mTime spent cycling: 2ms[0m
[0mExpensive rules:
Inconsistency: succeeded 0 times (0ms), failed 75 times (285ms)
SubstR: succeeded 72 times (46ms), failed 145 times (3ms)
CheckPost: succeeded 0 times (0ms), failed 59 times (45ms)
Open: succeeded 7 times (37ms), failed 8 times (0ms)
AbduceCall: succeeded 6 times (19ms), failed 9 times (12ms)
[0m
[0mSMTSolving          468ms
CyclicProofChecker  0ms  
                    468ms[0m
[0mvoid treefree2 (loc x, loc y) {
  if (x == 0) {
    if (y == 0) {
    } else {
      let l = *(y + 1);
      let r = *(y + 2);
      treefree2(l, r);
      free(y);
    }
  } else {
    let lx = *(x + 1);
    let rx = *(x + 2);
    treefree2(lx, rx);
    if (y == 0) {
      free(x);
    } else {
      let l = *(y + 1);
      let r = *(y + 2);
      treefree2(l, r);
      free(y);
      free(x);
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/copy] should be able to synthesize a tree copy (with elements)

[0mGoals generated: 4379[0m
[0mGoals expanded: 4161[0m
[0mAnd-nodes backtracked: 3469[0m
[0mMaximum worklist size: 241[0m
[0mMaximum goal depth: 84[0m
[0mFinal memo size: (3256,9,659)[0m
[0mFinal size of SMT cache: 282[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 70 times (110ms), failed 2239 times (969ms)
CheckPost: succeeded 569 times (380ms), failed 1471 times (120ms)
SubstR: succeeded 1200 times (417ms), failed 3267 times (24ms)
HeapUnifyPure: succeeded 456 times (151ms), failed 190 times (1ms)
FrameUnfold: succeeded 260 times (98ms), failed 186 times (26ms)
[0m
[0mSMTSolving          1599ms
CyclicProofChecker  0ms   
                    1599ms[0m
[tree/flatten] should be able to flatten the tree into a list

[35m
[tree/flatten]:[0m
[0m[0m
[34mvoid flatten(z loc) []
{z :-> x ** tree(x, s)<_alpha_10>}
{z :-> y ** sll(y, s)<_alpha_11>}
[0m
[32mSuccessfully synthesised in 2240 milliseconds:[0m
[0mGoals generated: 509[0m
[0mGoals expanded: 444[0m
[0mAnd-nodes backtracked: 128[0m
[0mMaximum worklist size: 43[0m
[0mMaximum goal depth: 96[0m
[0mFinal memo size: (122,255,0)[0m
[0mFinal size of SMT cache: 167[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 21 times (66ms), failed 231 times (346ms)
CheckPost: succeeded 52 times (246ms), failed 85 times (53ms)
Inconsistency: succeeded 0 times (0ms), failed 235 times (198ms)
*Partial: succeeded 32 times (21ms), failed 235 times (38ms)
Read: succeeded 23 times (23ms), failed 147 times (28ms)
[0m
[0mSMTSolving          988ms
CyclicProofChecker  1ms  
                    989ms[0m
[0m{z :-> x ** tree(x, s)<_alpha_10>}
{z :-> y ** sll(y, s)<_alpha_11>}
void flatten (loc z) {
  let x = *z;
  if (x == 0) {
  } else {
    let v = *x;
    let l = *(x + 1);
    let r = *(x + 2);
    *z = l;
    flatten(z);
    let y = *z;
    *z = r;
    flatten(z);
    flatten130(y, v, x, z);
  }
}

{_alpha_1x1 < _alpha_10 && _alpha_2x1 < _alpha_10 && not (x == 0) && not (x == z) && not (z == 0) ; (x + 1) :-> lx11 ** (x + 2) :-> rx11 ** x :-> v ** z :-> y2 ** sll(y1, s1x1)<_alpha_111>[1,0] ** sll(y2, s2x1)<_alpha_112>[1,0] ** [x, 3]}
{not (z == 0) ; z :-> y ** sll(y, {v} ++ s1x1 ++ s2x1)<_alpha_11>}
void flatten130 (loc y1, int v, loc x, loc z) {
  let y2 = *z;
  if (y1 == 0) {
    let y = malloc(2);
    free(x);
    *z = y;
    *y = v;
    *(y + 1) = y2;
  } else {
    let n = *(y1 + 1);
    flatten130(n, v, x, z);
    let y = *z;
    *z = y1;
    *(y1 + 1) = y;
  }
}[0m
[0m-----------------------------------------------------[0m
[tree/flatten-dll-linear] flatten a tree into a doubly-linked list in learn time

[0mGoals generated: 4810[0m
[0mGoals expanded: 4597[0m
[0mAnd-nodes backtracked: 3590[0m
[0mMaximum worklist size: 107[0m
[0mMaximum goal depth: 90[0m
[0mFinal memo size: (2853,614,382)[0m
[0mFinal size of SMT cache: 1262[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 287 times (709ms), failed 1860 times (1928ms)
CheckPost: succeeded 708 times (1035ms), failed 529 times (756ms)
Inconsistency: succeeded 18 times (40ms), failed 2066 times (696ms)
SubstR: succeeded 1096 times (382ms), failed 2484 times (33ms)
Read: succeeded 95 times (52ms), failed 1573 times (243ms)
[0m
[0mSMTSolving          4852ms
CyclicProofChecker  0ms   
                    4852ms[0m
[bst/insert] binary search tree: insert an element

[0mGoals generated: 3035[0m
[0mGoals expanded: 2637[0m
[0mAnd-nodes backtracked: 1544[0m
[0mMaximum worklist size: 375[0m
[0mMaximum goal depth: 74[0m
[0mFinal memo size: (1325,149,907)[0m
[0mFinal size of SMT cache: 697[0m
[0mTime spent cycling: 1ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 238 times (2270ms), failed 97 times (56ms)
PostInconsistent: succeeded 148 times (289ms), failed 1040 times (1878ms)
SubstR: succeeded 756 times (404ms), failed 1646 times (17ms)
Inconsistency: succeeded 9 times (35ms), failed 1053 times (339ms)
Close: succeeded 149 times (250ms), failed 3 times (0ms)
[0m
[0mSMTSolving          4685ms
CyclicProofChecker  0ms   
                    4685ms[0m
[bst/min] binary search tree: find smallest element

[0mGoals generated: 2352[0m
[0mGoals expanded: 2264[0m
[0mAnd-nodes backtracked: 1592[0m
[0mMaximum worklist size: 190[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (1307,8,574)[0m
[0mFinal size of SMT cache: 731[0m
[0mTime spent cycling: 6ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 21 times (109ms), failed 1107 times (2864ms)
CheckPost: succeeded 444 times (1502ms), failed 483 times (128ms)
Inconsistency: succeeded 0 times (0ms), failed 601 times (368ms)
SubstR: succeeded 548 times (236ms), failed 1496 times (18ms)
Read: succeeded 22 times (23ms), failed 531 times (120ms)
[0m
[0mSMTSolving          4824ms
CyclicProofChecker  3ms   
                    4827ms[0m
[bst/max] binary search tree: find smallest element

[0mGoals generated: 2324[0m
[0mGoals expanded: 2234[0m
[0mAnd-nodes backtracked: 1555[0m
[0mMaximum worklist size: 190[0m
[0mMaximum goal depth: 83[0m
[0mFinal memo size: (1278,8,581)[0m
[0mFinal size of SMT cache: 727[0m
[0mTime spent cycling: 10ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 21 times (113ms), failed 1097 times (2869ms)
CheckPost: succeeded 438 times (1573ms), failed 483 times (137ms)
Inconsistency: succeeded 0 times (0ms), failed 591 times (366ms)
SubstR: succeeded 536 times (241ms), failed 1486 times (16ms)
Read: succeeded 22 times (26ms), failed 521 times (130ms)
[0m
[0mSMTSolving          4897ms
CyclicProofChecker  4ms   
                    4901ms[0m
[bst/list-to-bst] covert a list into a BST

[35m
[bst/list-to-bst]:[0m
[0mmaxCloseDepth = 2, branchAbduction = true[0m
[34mvoid toBST(x loc, r loc) []
{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_4>}
{r :-> y ** bst(y, s, n)<_alpha_5>}
[0m
[32mSuccessfully synthesised in 11678 milliseconds:[0m
[0mGoals generated: 1736[0m
[0mGoals expanded: 1699[0m
[0mAnd-nodes backtracked: 1239[0m
[0mMaximum worklist size: 54[0m
[0mMaximum goal depth: 102[0m
[0mFinal memo size: (990,292,0)[0m
[0mFinal size of SMT cache: 869[0m
[0mTime spent cycling: 0ms[0m
[0mExpensive rules:
AbduceBranch: succeeded 297 times (2887ms), failed 123 times (55ms)
PostInconsistent: succeeded 41 times (143ms), failed 765 times (2322ms)
Inconsistency: succeeded 18 times (52ms), failed 675 times (434ms)
CheckPost: succeeded 53 times (381ms), failed 130 times (42ms)
SubstR: succeeded 424 times (328ms), failed 1003 times (10ms)
[0m
[0mSMTSolving          5907ms
CyclicProofChecker  0ms   
                    5907ms[0m
[0m{0 <= n ; r :-> 0 ** sll(x, s, n)<_alpha_4>}
{r :-> y ** bst(y, s, n)<_alpha_5>}
void toBST (loc x, loc r) {
  if (x == 0) {
  } else {
    let v = *x;
    let n = *(x + 1);
    toBST(n, r);
    toBST011402013(v, x, r);
  }
}

{0 <= len1x && 0 <= len1x + 1 && _alpha_0x < _alpha_4 && not (r == 0) && not (r == x) && not (x == 0) && true ; (x + 1) :-> nxtx1 ** r :-> y1 ** x :-> vx ** bst(y1, s1x, len1x)<_alpha_51>[1,0] ** [x, 2]}
{not (r == 0) ; r :-> y ** bst(y, [vx] ++ s1x, len1x + 1)<_alpha_5>}
void toBST011402013 (int vx, loc x, loc r) {
  let y1 = *r;
  if (y1 == 0) {
    let y = malloc(3);
    free(x);
    *r = y;
    *y = vx;
    *(y + 1) = 0;
    *(y + 2) = 0;
  } else {
    let v = *y1;
    if (vx <= v && v <= vx) {
      let l = *(y1 + 1);
      let ry = *(y1 + 2);
      *r = l;
      toBST011402013(vx, x, r);
      let y2 = *r;
      let y = malloc(3);
      free(y1);
      *r = y;
      *y = vx;
      *(y + 1) = y2;
      *(y + 2) = ry;
    } else {
      if (vx <= v) {
        let l = *(y1 + 1);
        let ry = *(y1 + 2);
        *r = l;
        toBST011402013(vx, x, r);
        let y2 = *r;
        let y = malloc(3);
        free(y1);
        *r = y;
        *y = v;
        *(y + 1) = y2;
        *(y + 2) = ry;
      } else {
        let l = *(y1 + 1);
        let ry = *(y1 + 2);
        *r = ry;
        toBST011402013(vx, x, r);
        let y2 = *r;
        let y = malloc(3);
        free(y1);
        *r = y;
        *y = v;
        *(y + 1) = l;
        *(y + 2) = y2;
      }
    }
  }
}[0m
[0m-----------------------------------------------------[0m
[rose-tree/copy] should be able to copy a rose tree

[0mGoals generated: 3674[0m
[0mGoals expanded: 3197[0m
[0mAnd-nodes backtracked: 1635[0m
[0mMaximum worklist size: 531[0m
[0mMaximum goal depth: 117[0m
[0mFinal memo size: (1336,56,1459)[0m
[0mFinal size of SMT cache: 505[0m
[0mTime spent cycling: 4ms[0m
[0mExpensive rules:
PostInconsistent: succeeded 225 times (450ms), failed 1154 times (936ms)
CheckPost: succeeded 192 times (465ms), failed 472 times (136ms)
Inconsistency: succeeded 17 times (44ms), failed 926 times (402ms)
SubstR: succeeded 1047 times (382ms), failed 1873 times (22ms)
Close: succeeded 315 times (369ms), failed 81 times (1ms)
[0m
[0mSMTSolving          2377ms
CyclicProofChecker  1ms   
                    2378ms[0m
