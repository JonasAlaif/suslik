package org.tygus.suslik.certification.targets.coq.logic.rules

import org.tygus.suslik.certification.targets.coq.language.Expressions._
import org.tygus.suslik.certification.targets.coq.logic.rules.Rules.CRuleApp
import org.tygus.suslik.certification.targets.coq.logic.Proof._

object NativeRules {
  case class CGhostElimApp(goal: CGoal, env: CEnvironment) extends CRuleApp(env) {
    private val appNames: Seq[CVar] = goal.pre.sigma.apps.map(app => CVar(s"H_${app.pred}"))

    override val nextEnvs: Seq[CEnvironment] = {
      val nextVars = goal.universalGhosts.toSet ++ appNames ++ Set(CVar("h"))
      Seq(env.copy(ctx = nextVars))
    }

    override def fn(steps: Seq[String]): String = {
      val builder = new StringBuilder()

      // Pull out any precondition ghosts and move precondition heap to the context
      builder.append("ssl_ghostelim_pre.\n")

      val ghosts = goal.universalGhosts
      val pre = goal.pre
      val ptss = pre.sigma.ptss
      val apps = pre.sigma.apps

      // move precondition's ghosts to context
      if (ghosts.nonEmpty) {
        builder.append("move=>")
        builder.append(nestedDestruct(ghosts))
        builder.append("//=.\n")
      }

      // substitute precondition's points-to assertions to conclusion
      if (ptss.nonEmpty || apps.isEmpty) {
        builder.append("move=>[->].\n")
      }

      // move precondition's predicate apps to context
      if (apps.nonEmpty) {
        val hApps = nestedDestruct(appNames)
        builder.append(s"move=>$hApps.\n")
      }

      // move heap validity assertion generated by ghR to context
      if (ghosts.nonEmpty) {
        builder.append("move=>H_valid.\n")
      }

      // print the rest
      steps.headOption.foreach(builder.append)

      builder.toString()
    }
  }

}
